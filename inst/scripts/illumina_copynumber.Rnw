%\VignetteIndexEntry{crlmm copy number Vignette for Illumina}
%\VignetteDepends{crlmm}
%\VignetteKeywords{crlmm, illumina}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage[margin=1in]{geometry}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}

\begin{document}
\title{Using \crlmm{} for copy number estimation and genotype calling
  with Illumina platforms}

\date{\today}

\author{Rob Scharpf}
\maketitle

<<crlmm, results=hide>>=
library(crlmm)
@

The vignette for copy number estimation for illumina platforms is
under development.  Please use the latest stable release of crlmm.

\end{document}

Allele-specific copy number estimation in the crlmm package is
available for several Illumina platforms.  As described in the
\texttt{copynumber} vignette, copy number estimation in \crlmm{} works
best when there are a sufficient number of samples such that AA, AB,
and BB genotypes are observed at most loci. For small studies (e.g.,
fewer than 50 samples), there will be a large number of SNPs that are
monomorphic. For monomorphic SNPs, the estimation problem becomes more
difficult and alternative strategies that estimate the relative total
copy number may be preferable.  In addition to installing \crlmm{},
one must also install the appropriate annotation package for the
Illumina platform.  In the following code, we list the platforms for
which annotation packages are currently available. Next we create a
directory where output files will be stored and indicate the directory
that contains the IDAT files that will be used in our analysis.


<<setup, echo=FALSE, results=hide>>=
options(width=70)
options(continue=" ")
@

<<libraries>>=
library(ff)
pkgs <- annotationPackages()
pkgs[grep("Crlmm", pkgs)]
if(getRversion() < "2.12.0"){
	rpath <- getRversion()
} else rpath <- "trunk"
outdir <- paste("/thumper/ctsa/snpmicroarray/rs/ProcessedData/crlmm/", rpath, "/illumina_vignette", sep="")
datadir <- "/thumper/ctsa/snpmicroarray/illumina/IDATS/370k"
@

%Options for controlling RAM with the \Rpackage{ff} package.

<<ldOptions>>=
ldPath(outdir)
ocProbesets(150e3)
ocSamples(200)
@


\paragraph{About this vignette.} This vignette was created using
Illumina IDAT files that are located in a specific directory on my
computer (\Robject{pathToCels}).  Long computations are saved in the
output directory \Robject{outdir}.  Users should modify these
variables as appropriate.  The following code chunk checks that that
these directories exist.

<<checkSetup>>=
if(!file.exists(outdir)) stop("Please specify valid directory for storing output")
if(!file.exists(datadir)) stop("Please specify the correct path to the CEL files")
@

\paragraph{Preprocessing Illumina IDAT files.}
To perform copy number analysis on the Illumina platform, several
steps are required.  The first step is to read in the IDAT files and
create a container for storing the red and green intensities. These
intensities are quantile normalized in the function
\Rfunction{crlmmIllumina}, and then genotyped using the crlmm
algorithm.  Details on the crlmm genotyping algorithm are described
elsewhere.  It is important to specify \Robject{save.it = TRUE} and
provide output files to store the quantile normalized intensities. We
will make use of the normalized intensities when we estimate copy
number.  The object returned by \Rfunction{crlmmIllumina} in an
instance of the \Robject{SnpSet} class, a container for storing the
genotype calls and the genotype confidence scores.  The genotype
confidence scores are saved as an integer, and can be converted back
to a $[0, 1]$ probability scale by the transformation
$round(-1000*log2(1-p))$.  At this point, one may want to extract the
scan date of the arrays for later use.  The scan dates can be pulled
from the RG object and added to the \Robject{SnpSet} returned by
\Rfunction{crlmmIllumina} as illustrated below.

%\texttt{copynumber.pdf} vignette, we provide an option to preprocess
%and genotype using ordinary matrices (large RAM, but quicker access)
%or \Robject{ff} objects (low RAM, but more I/O overhead). In the
%analysis below, the sample size is small (n=43) and we use matrices.
%(Users wanting the \Rpackage{ff} implementation should try
%\Rfunction{crlmm:::crlmmIllumina2} with the same arguments.)


<<samplesToProcess>>=
samplesheet = read.csv(file.path(datadir, "HumanHap370Duo_Sample_Map.csv"), header=TRUE, as.is=TRUE)
samplesheet <- samplesheet[-c(28:46,61:75,78:79), ]
arrayNames <- file.path(datadir, unique(samplesheet[, "SentrixPosition"]))
grnfiles = all(file.exists(paste(arrayNames, "_Grn.idat", sep="")))
redfiles = all(file.exists(paste(arrayNames, "_Red.idat", sep="")))
@

<<genotype>>=
load.it <- TRUE
if(!load.it){
	rmFiles <- list.files(outdir, pattern=".ff", full.names=TRUE)
	unlink(rmFiles)
}
container <- checkExists("container", .path=outdir,
			 .FUN=crlmm:::genotype.Illumina,
			 sampleSheet=samplesheet,
			 path=dirname(arrayNames[1]),
			 arrayInfoColNames=list(barcode=NULL, position="SentrixPosition"),
			 cdfName="human370v1c",
			 .load.it=load.it)
cnSet <- checkExists("cnSet", .path=outdir, .FUN=crlmmCopynumber, object=container, .load.it=load.it)
@


<<copynumberObject>>=
marker.index <- which(chromosome(cnSet) <= 22)## & isSnp(cnSet))
sample.index <- 1:5 ## first five samples
invisible(open(cnSet))
copynumberSet <- as(cnSet[marker.index, 1:5], "CopyNumberSet")
invisible(close(cnSet))
copynumberSet <- copynumberSet[order(chromosome(copynumberSet), position(copynumberSet)), ]
indices <- split(1:nrow(copynumberSet), chromosome(copynumberSet))
dup.index <- unlist(sapply(indices, function(i, position)  i[duplicated(position[i])], position=position(copynumberSet)))
if(length(dup.index) > 0) copynumberSet <- copynumberSet[-dup.index, ]
## exclude any rows that are all missing
missing.index <- which(rowSums(is.na(copyNumber(copynumberSet))) == ncol(copynumberSet))
copynumberSet <- copynumberSet[-missing.index, ]
@

<<hmm>>=
if(require(VanillaICE)){
	hmmOpts <- hmm.setup(copynumberSet, c("hom-del", "hem-del", "normal", "amp"),
			     copynumberStates=0:3, normalIndex=3,
			     log.initialP=rep(log(1/4), 4))
	timing <- system.time(fit.cn <- hmm(copynumberSet, hmmOpts, verbose=FALSE))
	hmm.df <- as.data.frame(fit.cn)
	print(hmm.df[1:5, c(2:4,7:9)])
}
@

<<cbs>>=
library("DNAcopy")
CNA.object <- CNA(genomdat=copyNumber(copynumberSet),
		  chrom=chromosome(copynumberSet),
		  maploc=position(copynumberSet),
		  data.type="logratio",
		  sampleid=sampleNames(copynumberSet))
smu.object <- smooth.CNA(CNA.object)
if(!load.it) unlink(file.path(outdir, "cbs.segments.rda"))
cbs.segments <- checkExists("cbs.segments", .path=outdir, .FUN=segment, x=smu.object, .load.it=load.it)
cbs.segments <- cbind(cbs.segments$output, cbs.segments$segRows)
cbs.segments$call <- rep(3, nrow(cbs.segments))
cbs.segments$call[cbs.segments$seg.mean > 2.5] <- 4
cbs.segments$call[cbs.segments$seg.mean < 1.25 & cbs.segments$seg.mean > 0.75] <- 2
cbs.segments$call[cbs.segments$seg.mean < 0.75] <- 1
cbs.ir <- RangedData(IRanges(cbs.segments$loc.start, cbs.segments$loc.end),
		     chrom=cbs.segments$chrom,
		     numMarkers=cbs.segments$num.mark,
		     seg.mean=cbs.segments$seg.mean,
		     cnCall=cbs.segments$call,
		     sampleId=cbs.segments$ID)
@

Plot the total copy number versus physical position for chromosome 1.
Overlay the copy number predictions from the HMM and a CNV call from
the segmentation obtained by thresholding the segment means.

<<smoothFig, fig=TRUE, width=8, height=8>>=
require(SNPchip)
CHR <- 1
cnSet2 <- copynumberSet
fit.cn2 <- fit.cn
cbs.ir2 <- cbs.ir
copynumberSet <- copynumberSet[which(chromosome(copynumberSet) == CHR), ]
layout(matrix(1:5, 5,1), heights=c(1, 1, 1, 1, 1))
par(mar=c(0.5, 0.5, 0.5, 0.5), las=1, oma=c(4, 4, 4, 4))
for(j in 1:5){
	fit.cn <- fit.cn2[fit.cn2$chrom==CHR & fit.cn2$sampleId == sampleNames(copynumberSet)[j], ]
	cbs.ir <- cbs.ir2[cbs.ir2$chrom==CHR & cbs.ir2$sampleId == sampleNames(copynumberSet)[j], ]
	plot(position(copynumberSet), copyNumber(copynumberSet)[, j], pch=".", cex=0.6,col="grey60", xaxt="n",
	     ylim=c(-1,6), ylab="total copy number",
	     yaxt="n",
	     xlim=c(0, max(position(copynumberSet))))
	axis(2, at=0:6, labels=0:6)
	if(j == 5){
		mtext("physical position (Mb)", 1, outer=TRUE, line=2)
		mtext("Chromosome 8", 3, line=0, outer=TRUE)
		at <- pretty(position(copynumberSet))
	}
	##Use polygon at bottom to show predictions
	w <- width(fit.cn)
	fit.cn <- fit.cn[order(w, decreasing=TRUE), ]
	##fit.cn <- fit.cn[fit.cn$numMarkers > 5, ]
	col <- c("blue", "black", "grey80", "red")
	x <- c(min(start(fit.cn)), max(end(fit.cn)))
	xx <- c(x, rev(x))
	y <- rep(c(-0.3, 0), each=2)
	polygon(xx, y, col="white")
	for(i in seq_along(w)){
		x <- c(start(fit.cn)[i], end(fit.cn)[i])
		xx <- c(x, rev(x))
		statecolor <- col[fit.cn$state[i]]
		polygon(xx, y, col=statecolor, border=statecolor)
	}
	w <- width(cbs.ir)
	cbs.ir <- cbs.ir[order(w, decreasing=TRUE), ]
	##cbs.ir <- cbs.ir[cbs.ir$numMarkers > 5, ]
	y <- rep(c(-1, -0.7), each=2)
	for(i in seq_along(w)){
		x <- c(start(cbs.ir)[i], end(cbs.ir)[i])
		xx <- c(x, rev(x))
		statecolor <- col[cbs.ir$cnCall[i]]
		polygon(xx, y, col=statecolor, border=statecolor)
	}
	axis(4, at=c(-0.9, -0.1), c("CBS", "HMM"), cex=0.8)
	data("chromosomeAnnotation")
	x <- as.integer(chromosomeAnnotation[8, 1:2])
	x <- c(x, rev(x))
	y <- c(-1, -1, 6, 6)
	polygon(x, y, border="white", col="white")
	## draw centromere
	if(j==5){
		legend("topright", fill=col, legend=c(0, 1, 2, expression(3+.)))
##		invisible(plotCytoband(8, label.cytoband=FALSE, xlim=c(0,max(position(copynumberSet)))))
		labels <- at/1e6
		axis(1, at=at, labels=labels, outer=T, line=0)
	}
}
@


Make a 4 x 4 table of the called states for each sample.

<<smooth>>=
fit.cn <- fit.cn2; cbs.ir <- cbs.ir2
nm.hmm <- sapply(split(fit.cn$numMarkers, fit.cn$sampleId), sum)
stopifnot(length(unique(nm.hmm)) == 1)
nm.cbs <- sapply(split(cbs.ir$numMarkers, cbs.ir$sampleId), sum)
stopifnot(length(unique(nm.cbs)) == 1)
stopifnot(all.equal(nm.cbs, nm.hmm))
hmm.states <- rep(fit.cn$state, fit.cn$numMarkers)
sample.id <- rep(fit.cn$sampleId, fit.cn$numMarkers)
hmm.states <- split(hmm.states, sample.id)
cbs.states <- rep(cbs.ir$cnCall, cbs.ir$numMarkers)
sample.id <- rep(cbs.ir$sampleId, cbs.ir$numMarkers)
cbs.states <- split(cbs.states, sample.id)
tabs <- vector("list", length(cbs.states))
for(i in seq_along(cbs.states)) tabs[[i]] <- table(cbs.states[[i]], hmm.states[[i]])
names(tabs) <- names(cbs.states)
@


\paragraph{Accessors for extracting the locus-level copy number
  estimates.}

As an example of how to use accessors to obtain the allele-specific CN
estimates, the following code chunk extracts the allele-specific copy
number for polymorphic markers on chromosome 21.

<<acn-accessor>>=
marker.index <- which(chromosome(cnSet) == 21 & isSnp(cnSet))
ca <- CA(cnSet, i=marker.index)
cb <- CB(cnSet, i=marker.index)
missing.index <- which(rowSums(is.na(ca))==ncol(cnSet))
ca <- ca[-missing.index, ]
cb <- cb[-missing.index, ]
@
\noindent Negating the \Robject{isSnp} function could be used to
extract the estimates at nonpolymorphic markers. For instance,
<<monomorphic-accessor>>=
cn.monomorphic <- CA(cnSet, i=which(chromosome(cnSet) == 21 & !isSnp(cnSet)))
@

At polymorphic loci, the total copy number is the sum of the number of
copies of the A allele and the number of copies for the B allele.  At
nonpolymorphic loci, the total copy number is the number of copies for
the A allele.  The helper function totalCopyNumber can be used to
extract the total copy number for all polymorphic and nonpolymorphic
markers.  Documentation of the \Rfunction{totalCopyNumber} will be
available in the devel version of the \Rpackage{oligoClasses}.

<<copyNumberHelper>>=
cn.total <- ca+cb
cn.total2 <- totalCopynumber(cnSet, i=marker.index)
cn.total2 <- cn.total2[-missing.index, ]
all.equal(cn.total2, cn.total)
@

A few simple visualizations may be helpful at this point. The first
plot is a histogram of the signal to noise ratio of the sample -- an
overall measure of how well the genotype clusters separate.  (This
statistic tends to be much higher for Illumina than for the Affymetrix
platforms.) The second is a visualization of the total copy number
estimates plotted versus physical position on chromosome 1 for the two
samples with the lowest (top) and highest (bottom) signal to noise
ratios.

<<snr, fig=TRUE>>=
open(cnSet$SNR)
snr <- cnSet$SNR[,]
hist(snr, breaks=15)
@

<<firstSample, fig=TRUE>>=
low.snr <- which(snr == min(snr))
high.snr <- which(snr == max(snr))
x <- position(cnSet)[marker.index]
x <- x[-missing.index]
par(mfrow=c(2,1), las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 1, 1,1))
for(j in c(low.snr, high.snr)){
	cn <- cn.total[, j]
	cn[cn < 0.05] <- 0.05
	plot(x,
	     cn,
	     pch=".", ylab="copy number", xaxt="n", ylim=c(0, 6))
}
axis(1, at=pretty(x), labels=pretty(x/1e6))
mtext("Mb", 1, outer=TRUE, line=2)
@

Here's a very simple approach to handle outliers by applying a running
median using a window of size 3.  Following outlier removal, we
suggest applying a wave correction to adjust for more global waves
followed by a segmentation or hidden markov model.

<<removeOutliers, fig=TRUE>>=
par(mfrow=c(2,1), las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 1, 1,1))
for(j in c(low.snr, high.snr)){
	cn <- cn.total[, j]
	x <- x[!is.na(cn)]
	cn <- cn[!is.na(cn)]
	y <- as.numeric(runmed(cn, k=3))
	plot(x,
	     y,
	     pch=".", ylab="copy number", xaxt="n", log="y", ylim=c(0.5,5))
	legend("topright", bty="n", legend=paste("SNR =", round(cnSet$SNR[j], 1)))
	abline(h=2, col="grey70")
}
axis(1, at=pretty(x), labels=pretty(x/1e6))
mtext("Mb", 1, outer=TRUE, line=2)
@

\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@


\end{document}



