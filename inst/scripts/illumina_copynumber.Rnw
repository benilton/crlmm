%\VignetteIndexEntry{crlmm copy number Vignette for Illumina}
%\VignetteDepends{crlmm}
%\VignetteKeywords{crlmm, illumina}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage[margin=1in]{geometry}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}
\newcommand{\ff}{\Rpackage{ff}}

\begin{document}
\title{Using \crlmm{} for copy number estimation and genotype calling
  with Illumina platforms}

\date{\today}

\author{Rob Scharpf}
\maketitle


\begin{abstract}
  This vignette illustrates the steps required prior to copy number
  analysis for Infinium platforms.  Specifically, we require
  construction of a container to store processed forms of the raw
  data, preprocessing to normalize the arrays, and genotyping using
  the CRLMM algorithm.  After completing these steps, users can refer
  to the copy number vignette.
\end{abstract}

\section{Setup}

<<crlmm, results=hide, echo=FALSE>>=
library(crlmm)
options(width=70)
options(continue=" ")
@

%\textbf{Supported platforms:} The supported Infinium platforms are
%those for which a corresponding annotation package is available.  The
%annotation packages contain information on the markers, such as
%physical position and chromosome, as well as pre-computed parameters
%estimated from HapMap used during the preprocessing and genotyping
%steps. Currently supported Infinium platforms are listed in the
%following code chunk.
The following codechunk declares a directory for saving \Robject{ff}
files that will contain the normalized intensities and the genotype
calls.

<<ldpath,results=hide>>=
library(ff)
if(getRversion() < "2.13.0"){
	rpath <- getRversion()
} else rpath <- "trunk"
outdir <- paste("/thumper/ctsa/snpmicroarray/rs/ProcessedData/crlmm/", rpath, "/illumina_vignette", sep="")
ldPath(outdir)
dir.create(outdir, recursive=TRUE, showWarnings=FALSE)
@

We will also store cached computations in the directory \verb+outdir+.

<<cacheSweave, echo=FALSE, results=hide>>=
library(cacheSweave)
setCacheDir(outdir)
@

We declare that \crlmm{} should process 150,000 markers at a time
(when possible) and/or 500 samples at a time.  As our example dataset
in this vignette contains fewer than 500 samples, all samples will be
processed simultaneously.

<<ram>>=
ocProbesets(150e3)
ocSamples(500)
@

\textbf{Limitations:} There is no minimum number of samples required
for preprocessing and genotyping.  However, for copy number estimation
the \crlmm{} package currently requires at least 10 samples per batch.
The parameter estimates for copy number and the corresponding
estimates of raw copy number will tend to be more noisy for batches
with small sample sizes (e.g., $<$ 50).  Chemistry plate or scan date
are often useful surrogates for batch.

\section{Initializing a container for storing processed data}

This section will initialize a container for storing processed forms
of the data, including the normalized intensities for the A and B
alleles and the CRLMM genotype calls and confidence scores.  In
addition, the container will store information on the markers
(physical position, chromosome, and a SNP indicator), the batch, and
the samples (e.g., gender).  To construct this container for Infinium
platforms, several steps are required.

We begin by specifying the path containing the raw IDAT files for a
set of samples from the Infinium 370k platform.

<<datadir>>=
datadir <- "/thumper/ctsa/snpmicroarray/illumina/IDATS/370k"
@

For Infinium platforms, an Illumina sample sheet containing
information for reading the raw IDAT files is required. Please refer
to the BeadStudio Genotyping guide, Appendix A, for additional
information.  The following code reads in the samplesheet for the IDAT
files on our local server. For our dataset, the file extensions are
`Grn.dat' and `Red.idat'.  We store the complete path to the filename
without the file extension in the \Robject{arrayNames} and check that
all of the green and red IDAT files exists.

<<samplesheet>>=
samplesheet = read.csv(file.path(datadir, "HumanHap370Duo_Sample_Map.csv"), header=TRUE, as.is=TRUE)
samplesheet <- samplesheet[-c(28:46,61:75,78:79), ]
arrayNames <- file.path(datadir, unique(samplesheet[, "SentrixPosition"]))
all(file.exists(paste(arrayNames, "_Grn.idat", sep="")))
all(file.exists(paste(arrayNames, "_Red.idat", sep="")))
arrayInfo <- list(barcode=NULL, position="SentrixPosition")
@

As discussed previously, all supported platforms have a corresponding
annotation package.  The appropriate annotation package is specified
by the platform identifier without the \verb+Crlmm+ postfix.

<<cdfname>>=
cdfName <- "human370v1c"
@

Next, we construct a character vector that specifies the batch for
each of the \Sexpr{length(arrayNames)} arrays.  Here, we have a small
dataset and process the samples in a single batch. Processing the
samples as a single batch is generally reasonable if the samples were
processed at similar times (e.g., within a few weeks).

<<batch>>=
batch <- rep("1", nrow(samplesheet))
@

Finally, we initialize an object of class \Robject{CNSet} using the
function \Rfunction{constructInf}.

<<container,cache=TRUE>>=
cnSet <- constructInf(sampleSheet=samplesheet,
		      arrayNames=arrayNames,
		      batch=batch,
		      arrayInfoColNames=arrayInfo,
		      cdfName=cdfName,
		      verbose=TRUE,
		      saveDate=TRUE)
@

A concise summary of the object's contents can be viewed with the
\Rfunction{print} function.

<<cnset>>=
print(cnSet)
@

Note that the above object does not yet contain any processed data
(only \verb+NA+'s) and several \verb+.ff+ files now appear in the
\verb+outdir+.  Again, these files should not be removed.

<<listff>>=
list.files(outdir, pattern=".ff")[1:5]
@

Finally, note that the elements of the \verb+assayData+ slot are
\Robject{ff} objects and not matrices. For the most part, the
\emph{appearance} that the data is stored in memory is preserved.


<<assaydataelements>>=
sapply(assayData(cnSet), function(x) class(x)[1])
@

\section{Preprocessing}

The raw intensities from the Infinium IDAT files are read and
normalized using the function \Rfunction{preprocessInf}.  The function
\Rfunction{preprocessInf} returns a \Robject{ff} object containing the
parameters for the mixture model used by the CRLMM genotyping
algorithm.

<<preprocess,cache=TRUE>>=
mixtureParams <- preprocessInf(cnSet=cnSet, sampleSheet=samplesheet, arrayNames=arrayNames, arrayInfoColNames=arrayInfo)
invisible(open(mixtureParams))
str(mixtureParams[])
invisible(close(mixtureParams))
@

Note that the normalized intensities for the A and B alleles are no
longer \verb+NA+s and can now be accessed and inspected using the
methods \Rfunction{A} and \Rfunction{B}, respectively.

<<intensities>>=
invisible(open(A(cnSet)))
invisible(open(B(cnSet)))
as.matrix(A(cnSet)[1:5, 1:5])
as.matrix(B(cnSet)[1:5, 1:5])
invisible(close(A(cnSet)))
invisible(close(B(cnSet)))
@


\section{Genotyping}


CRLMM genotype calls and confidence scores are estimated using the
function \Rfunction{genotypeInf}.

<<genotype,cache=TRUE>>=
updated <- genotypeInf(cnSet, mixtureParams=mixtureParams)
print(updated)
@

The posterior probabilities for the
genotype calls in the \verb+callProbability+ element of the
\verb+assayData+ are stored as integers to reduce the file size on
disk.  However, the scores can be easily transformed back to the
probability scale using the \Rfunction{i2p} function as illustrated in
the following code chunk.

<<callprobs>>=
invisible(open(snpCallProbability(cnSet)))
callProbs <- as.matrix(snpCallProbability(cnSet)[1:5, 1:5])
i2p(callProbs)
invisible(close(snpCallProbability(cnSet)))
@

%As described in the \texttt{copynumber} vignette, copy number
%estimation in \crlmm{} works best when there are a sufficient number
%of samples such that AA, AB, and BB genotypes are observed at most
%loci. For small studies (e.g., fewer than 50 samples), there will be a
%large number of SNPs that are monomorphic. For monomorphic SNPs, the
%estimation problem becomes more difficult and alternative strategies
%that estimate the relative total copy number may be preferable.  In
%addition to installing \crlmm{}, one must also install the appropriate
%annotation package for the Illumina platform.  In the following code,
%we list the platforms for which annotation packages are currently
%available. Next we create a directory where output files will be
%stored and indicate the directory that contains the IDAT files that
%will be used in our analysis.

\textbf{Wrapper:} The construction of a \Rclass{CNSet} object,
preprocessing, and genotype calling are wrapped into a convenience
function called \Rfunction{genotype.Illumina}.

<<genotype.Illumina,cache=TRUE,results=hide>>=
cnSet2 <- genotype.Illumina(sampleSheet=samplesheet,
			    arrayNames=arrayNames,
			    arrayInfoColNames=arrayInfo,
			    cdfName="human370v1c",
			    batch=batch)
@

<<checkIdenticalCalls>>=
invisible(open(calls(cnSet)))
invisible(open(calls(cnSet2)))
snp.index <- which(isSnp(cnSet))
identical(calls(cnSet)[snp.index, 1:20], calls(cnSet2)[snp.index, 1:20])
invisible(close(calls(cnSet)))
invisible(close(calls(cnSet2)))
@

To fully remove the data associated with the \Robject{cnSet2} object,
one should use the \Rfunction{delete} function in the \Rpackage{ff}
package followed by the \Rfunction{rm} function.  The following code
is not evaluated is it would change the results of the cached
computations in the previous code chunk.

<<delete, eval=FALSE>>=
lapply(assayData(cnSet2), delete)
lapply(batchStatistics(cnSet2), delete)
delete(cnSet2$gender)
delete(cnSet2$SNR)
delete(cnSet2$SKW)
rm(cnSet2)
@

\end{document}
