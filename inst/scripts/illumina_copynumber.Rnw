%\VignetteIndexEntry{crlmm copy number Vignette for Illumina}
%\VignetteDepends{crlmm}
%\VignetteKeywords{crlmm, illumina}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage[margin=1in]{geometry}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}
\newcommand{\ff}{\Rpackage{ff}}

\begin{document}
\title{Using \crlmm{} for copy number estimation and genotype calling
  with Illumina platforms}

\date{\today}

\author{Rob Scharpf}
\maketitle


\begin{abstract}
  This vignette illustrates the steps required prior to copy number
  analysis for Infinium platforms.  Specifically, we require
  construction of a container to store processed forms of the raw
  data, preprocessing to normalize the arrays, and genotyping using
  the CRLMM algorithm.  After completing these steps, users can refer
  to the copy number vignette.
\end{abstract}

\section{Infrastructure}

<<crlmm, results=hide, echo=FALSE>>=
library(crlmm)
options(width=70)
options(continue=" ")
@

\textbf{Supported platforms:} The supported Infinium platforms are
those for which a corresponding annotation package is available.  The
annotation packages contain information on the markers, such as
physical position and chromosome, as well as pre-computed parameters
estimated from HapMap used during the preprocessing and genotyping
steps. Currently supported Infinium platforms are listed in the
following code chunk.

<<supportedPlatforms>>=
pkgs <- annotationPackages()
crlmm.pkgs <- pkgs[grep("Crlmm", pkgs)]
crlmm.pkgs[grep("human", crlmm.pkgs)]
@

\textbf{Large data:} In order to reduce \crlmm{}'s memory footprint,
we require the \Rpackage{ff} for copy number estimation.  The
\Rpackage{ff} package provides infrastructure for accessing and
writing data to disk instead of keeping data in memory.  Each element
of the \verb+assayData+ and \verb+batchStatistics+ slot of the
\Rclass{CNSet} class are \Robject{ff} objects.  \Robject{ff} objects
in the \R{} workspace contain pointers to several files with the
\verb+.ff+ extension.  The location of where the data is stored on
disk is specified by use of the \Rfunction{ldPath} function.

<<ldpath,results=hide>>=
library(ff)
if(getRversion() < "2.13.0"){
	rpath <- getRversion()
} else rpath <- "trunk"
outdir <- paste("/thumper/ctsa/snpmicroarray/rs/ProcessedData/crlmm/", rpath, "/illumina_vignette", sep="")
ldPath(outdir)
dir.create(outdir, recursive=TRUE, showWarnings=FALSE)
@

Users should not move or rename this directory.  If only output files
are stored in \verb+outdir+, one can either remove the entire
directory prior to rerunning the analysis or all of the '.ff' files.
Otherwise, one would accumulate a large number of '.ff' files on disk
that are no longer in use.

As none of the functions for preprocessing, genotyping, or copy number
estimation simultaneously require all samples and all probes in
memory, memory-usage by \crlmm{} can be fine tuned by reading in and
processing subsets of the markers and/or samples. The functions
\Rfunction{ocSamples} and \Rfunction{ocProbesets} in the
\Rpackage{oligoClasses} package can be used to declare how many
markers and samples to read at once.  In general, specifying smaller
values should reduce the RAM required for a particular job, but would
be expected to have an increased run-time. In the following
code-chunk, we declare that \crlmm{} should process 150,000 markers at
a time (when possible) and 500 samples at a time.  (As our dataset in
this vignette only contains 43 samples, the \Rfunction{ocSamples}
option would not have any effect.)  One can view the current settings
for these commands, by typing the functions without an argument.

<<ram>>=
ocSamples()
ocProbesets()
ocProbesets(150e3)
ocSamples(500)
ocSamples()
ocProbesets()
@

<<cacheSweave, echo=FALSE, results=hide>>=
library(cacheSweave)
setCacheDir(outdir)
@

\textbf{Limitations:} There is no minimum number of samples required
for preprocessing and genotyping.  However, for copy number estimation
the \crlmm{} package currently requires at least 10 samples per batch.
The parameter estimates for copy number and the corresponding
estimates of raw copy number will tend to be more noisy for batches
with small sample sizes (e.g., $<$ 50).  Chemistry plate or scan date
are often useful surrogates for batch.

\section{Initializing a container for storing processed data}

This section will initialize a container for storing processed forms
of the data, including the normalized intensities for the A and B
alleles and the CRLMM genotype calls and confidence scores.  In
addition, the container will store information on the markers
(physical position, chromosome, and a SNP indicator), the batch, and
the samples (e.g., gender).  To construct this container for Infinium
platforms, several steps are required.

We begin by specifying the path containing the raw IDAT files for a
set of samples from the Infinium 370k platform.

<libraries>>=
datadir <- "/thumper/ctsa/snpmicroarray/illumina/IDATS/370k"
@

For Infinium platforms, an Illumina sample sheet containing
information for reading the raw IDAT files is required. Please refer
to the BeadStudio Genotyping guide, Appendix A, for additional
information.  The following code reads in the samplesheet for the IDAT
files on our local server. For our dataset, the file extensions are
`Grn.dat' and `Red.idat'.  We store the complete path to the filename
without the file extension in the \Robject{arrayNames} and check that
all of the green and red IDAT files exists.

<<samplesheet>>=
samplesheet = read.csv(file.path(datadir, "HumanHap370Duo_Sample_Map.csv"), header=TRUE, as.is=TRUE)
samplesheet <- samplesheet[-c(28:46,61:75,78:79), ]
arrayNames <- file.path(datadir, unique(samplesheet[, "SentrixPosition"]))
all(file.exists(paste(arrayNames, "_Grn.idat", sep="")))
all(file.exists(paste(arrayNames, "_Red.idat", sep="")))
arrayInfo <- list(barcode=NULL, position="SentrixPosition")
@

As discussed previously, all supported platforms have a corresponding
annotation package.  The appropriate annotation package is specified
by the platform identifier without the \verb+Crlmm+ postfix.

<<cdfname>>=
cdfName <- "human370v1c"
@

Next, we construct a character vector that specifies the batch for
each of the \Sexpr{length(arrayNames)} arrays.  Here, we have a small
dataset and process the samples in a single batch. Processing the
samples as a single batch is generally reasonable if the samples were
processed at similar times (e.g., within a few weeks).

<<batch>>=
batch <- rep("1", nrow(samplesheet))
@

Finally, we initialize an object of class \Robject{CNSet} using the
function \Rfunction{constructInf}.

<<container,cache=TRUE>>=
cnSet <- constructInf(sampleSheet=samplesheet,
		      arrayNames=arrayNames,
		      batch=batch,
		      arrayInfoColNames=arrayInfo,
		      cdfName=cdfName,
		      verbose=TRUE,
		      saveDate=TRUE)
@

A concise summary of the object's contents can be viewed with the
\Rfunction{print} function.

<<cnset>>=
print(cnSet)
@

Note that the above object does not yet contain any processed data
(only \verb+NA+'s) and several \verb+.ff+ files now appear in the
\verb+outdir+.  Again, these files should not be removed.

<<listff>>=
list.files(outdir, pattern=".ff")[1:5]
@

Finally, note that the elements of the \verb+assayData+ slot are
\Robject{ff} objects and not matrices. For the most part, the
\emph{appearance} that the data is stored in memory is preserved.


<<assaydataelements>>=
sapply(assayData(cnSet), function(x) class(x)[1])
@

\section{Preprocessing}

The raw intensities from the Infinium IDAT files are read and
normalized using the function \Rfunction{preprocessInf}.  The function
\Rfunction{preprocessInf} returns a \Robject{ff} object containing the
parameters for the mixture model used by the CRLMM genotyping
algorithm.

<<preprocess,cache=TRUE>>=
mixtureParams <- preprocessInf(cnSet=cnSet, sampleSheet=samplesheet, arrayNames=arrayNames, arrayInfoColNames=arrayInfo)
invisible(open(mixtureParams))
str(mixtureParams[])
invisible(close(mixtureParams))
@

Note that the normalized intensities for the A and B alleles are no
longer \verb+NA+s and can now be accessed and inspected using the
methods \Rfunction{A} and \Rfunction{B}, respectively.

<<intensities>>=
invisible(open(A(cnSet)))
invisible(open(B(cnSet)))
as.matrix(A(cnSet)[1:5, 1:5])
as.matrix(B(cnSet)[1:5, 1:5])
invisible(close(A(cnSet)))
invisible(close(B(cnSet)))
@


\section{Genotyping}


CRLMM genotype calls and confidence scores are estimated using the
function \Rfunction{genotypeInf}.

<<genotype,cache=TRUE>>=
updated <- genotypeInf(cnSet, mixtureParams=mixtureParams)
print(updated)
@

The posterior probabilities for the
genotype calls in the \verb+callProbability+ element of the
\verb+assayData+ are stored as integers to reduce the file size on
disk.  However, the scores can be easily transformed back to the
probability scale using the \Rfunction{i2p} function as illustrated in
the following code chunk.

<<callprobs>>=
invisible(open(snpCallProbability(cnSet)))
callProbs <- as.matrix(snpCallProbability(cnSet)[1:5, 1:5])
i2p(callProbs)
invisible(close(snpCallProbability(cnSet)))
@

%As described in the \texttt{copynumber} vignette, copy number
%estimation in \crlmm{} works best when there are a sufficient number
%of samples such that AA, AB, and BB genotypes are observed at most
%loci. For small studies (e.g., fewer than 50 samples), there will be a
%large number of SNPs that are monomorphic. For monomorphic SNPs, the
%estimation problem becomes more difficult and alternative strategies
%that estimate the relative total copy number may be preferable.  In
%addition to installing \crlmm{}, one must also install the appropriate
%annotation package for the Illumina platform.  In the following code,
%we list the platforms for which annotation packages are currently
%available. Next we create a directory where output files will be
%stored and indicate the directory that contains the IDAT files that
%will be used in our analysis.

\textbf{Wrapper:} The construction of a \Rclass{CNSet} object,
preprocessing, and genotype calling are wrapped into a convenience
function called \Rfunction{genotype.Illumina}.

<<genotype.Illumina,cache=TRUE,results=hide>>=
cnSet2 <- genotype.Illumina(sampleSheet=samplesheet,
			    arrayNames=arrayNames,
			    arrayInfoColNames=arrayInfo,
			    cdfName="human370v1c",
			    batch=batch)
@

<<checkIdenticalCalls>>=
invisible(open(calls(cnSet)))
invisible(open(calls(cnSet2)))
snp.index <- which(isSnp(cnSet))
identical(calls(cnSet)[snp.index, 1:20], calls(cnSet2)[snp.index, 1:20])
invisible(close(calls(cnSet)))
invisible(close(calls(cnSet2)))
@

To fully remove the data associated with the \Robject{cnSet2} object,
one should use the \Rfunction{delete} function in the \Rpackage{ff}
package followed by the \Rfunction{rm} function.  The following code
is not evaluated is it would change the results of the cached
computations in the previous code chunk.

<<delete, eval=FALSE>>=
lapply(assayData(cnSet2), delete)
lapply(batchStatistics(cnSet2), delete)
delete(cnSet2$gender)
delete(cnSet2$SNR)
delete(cnSet2$SKW)
rm(cnSet2)
@

\end{document}
