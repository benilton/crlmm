%\VignetteIndexEntry{crlmm copy number Vignette}
%\VignetteDepends{crlmm, genomewidesnp6Crlmm}
%\VignetteKeywords{crlmm, SNP 6}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}

\begin{document}
\title{Trisomy analysis}
\date{May, 2009}
\author{Rob Scharpf}
\maketitle

<<setup, echo=FALSE, results=hide>>=
options(width=60)
options(continue=" ")
options(prompt="R> ")
@ 

\section{Estimating copy number}

At present, software for copy number estimation is provided only for the
Affymetrix 6.0 platform.  This vignette estimates copy number for the
HapMap samples.

\subsection{Preprocess and genotype the samples}

We preprocess and genotype the samples as described in the CRLMM
vignette.

<<test, eval=FALSE, echo=FALSE>>=
library(crlmm)
load("~/madman/Rpacks/crlmm/inst/scripts/example.cnset.rda")

chromosome(example.cnset)[1:5]
position(example.cnset)[1:5]
scanDates(example.cnset)[1:5]
@ 

<<requiredPackages>>=
library(crlmm)
library(genomewidesnp6Crlmm)
@ 

Specify the complete path for the CEL files and a directory in which to
store intermediate files:

<<celfiles>>=
celFiles <- list.celfiles("/thumper/ctsa/snpmicroarray/hapmap/raw/affy/1m", full.names=TRUE, pattern=".CEL")
outdir <- "/thumper/ctsa/snpmicroarray/rs/data/hapmap/1m/affy"
@ 

Preprocess and genotype (for more info see the crlmm vignette):

<<preprocessAndGenotype>>=
crlmmFilenames <- file.path(outdir, paste("crlmmResults_", 1:24, ".rda", sep=""))
if(!all(file.exists(crlmmFilenames))){
	message("Preprocessing and crlmm genotyping.  Results are written to", outdir, "...")
	intensityFile <- file.path(outdir, "intensities.rda")		
	crlmmWrapper(celFiles, outdir, save.it=TRUE, intensityFile=intensityFile)
}
@ 

Load results for chromosome 22.

<<crlmmList-show>>=
CHR <- 22
if(!exists("crlmmResults")) load(file.path(outdir, paste("crlmmResults_", CHR, ".rda", sep="")))
class(crlmmResults)
show(crlmmResults)
@ 

\subsection{Copy number}

We require 6 items for copy number estimation:

\begin{itemize}
  \item quantile-normalized A intensities (I1 x J)
  \item quantile-normalized B intensities (I1 x J)
  \item quantile-normalized intensities from nonpolymorphic (NP) probes (I2 x J)
  \item genotype calls (I1 x J)
  \item confidence scores of the genotype calls  (I1 x J)
  \item signal to noise ratio (SNR) of the samples (J)
  \end{itemize}
  
  The above items are contained in the \Robject{crlmmResults} object. A
  histogram of the signal to noise ratio for the HapMap samples:

<<plotSnr, fig=TRUE>>=
hist(crlmmResults[[2]]$SNR, xlab="SNR", main="")
@ 

<<setSNRmin, echo=FALSE>>=
SNRmin <- 5
@ 

We suggest excluding samples with a signal to noise ratio less than
\Sexpr{SNRmin}.  As batch effects can be very large in the
quantile-normalized intensities, we suggest adjusting for date or
chemistry plate.  Ideally, one would have 70+ files in a given
batch. Here we make a table of date versus ancestry:

<<specifyBatch>>=
sns <- sampleNames(crlmmResults)
sns[1]
batch <- substr(basename(sns), 13, 13)
table(batch)
table(format(as.POSIXlt(scanDates(crlmmResults)), "%d %b %Y"), batch)
@ 

As all of these samples were run on the first week of March, we would
expect that any systematic artifacts to the intensities that develop
over time to be minimal (a best case scenario).  As this is typically
not the case, we illustrate how one may adjust for batch using the
chemistry plate as an argument for \Robject{batch} in the
\Robject{computeCopynumber} function.

<<computeCopynumber>>=
if(!exists("cnset")){
	if(file.exists(file.path(outdir, paste("cnset_", CHR, ".rda", sep="")))) load(file.path(outdir, paste("cnset_", CHR, ".rda", sep="")))	
	else {
		cnset <- computeCopynumber(crlmmResults, SNRmin=5, batch=batch, CHR=CHR, cdfName="genomewidesnp6")
		save(cnset, file=file.path(outdir, paste("cnset_", CHR, ".rda", sep="")))
	}
}
scanDates(cnset) <- scanDates(crlmmResults)
cnset <- cnset[order(chromosome(cnset), position(cnset)), ]
crlmmResults <- crlmm:::harmonizeDimnamesTo(crlmmResults, cnset)
@ 

<<example.cnset, eval=FALSE, echo=FALSE>>=
example.crlmmResults <- crlmmResults[1:1000, 1:100]
example.cnset <- cnset[1:1000, 1:100]
save(example.cnset, file="~/madman/Rpacks/crlmm/inst/scripts/example.cnset.rda")
save(example.crlmmResults, file="~/madman/Rpacks/crlmm/inst/scripts/example.crlmmResults.rda")
@ 

The above algorithm for estimating copy number is predicated on the
assumption that most samples within a batch have copy number 2 at any
given locus.  For common copy number variants, this assumption may not
hold.  An additional iteration using a bias correction provides
additional robustness to this assumption.  Set the \Robject{bias.adj}
argument to \Robject{TRUE}:

<<biasAdjustment, eval=FALSE>>=
cnset <- computeCopynumber(crlmmResults, SNRmin=5, batch=batch, CHR=CHR, 
			   cdfName="genomewidesnp6", bias.adj=TRUE)
@ 

\section{Suggested plots}

\paragraph{One sample at a time}

Plot physical position versus copy number for the first sample.  Recall
that the copy number estimates were multiplied by 100 and stored as an
integer.

<<oneSample, fig=TRUE, width=8, height=4, include=FALSE, eval=FALSE>>=
par(las=1)
plot(position(cnset), copyNumber(cnset)[, 1], pch=".", cex=2, xaxt="n", col="grey20", ylim=c(0,6), 
     ylab="copy number", xlab="physical position (Mb)",
     main=paste(sampleNames(cnset)[1], ", CHR:", unique(chromosome(cnset))))
points(position(cnset)[cnIndex(cnset)], copyNumber(cnset)[cnIndex(cnset), 1],
       pch=".", cex=2, col="lightblue")
axis(1, at=pretty(range(position(cnset))), labels=pretty(range(position(cnset)))/1e6)
@ 

<<idiogram, eval=FALSE, echo=FALSE>>=
require(SNPchip)
plotCytoband(22, new=FALSE, cytoband.ycoords=c(5.8, 6.0), label.cytoband=FALSE)
@ 

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-oneSample}
  \caption{Total copy number (y-axis) for chromosome 22 plotted
    against physical position (x-axis) for one sample.  }
\end{figure}

\paragraph{One SNP at a time}

Plot the prediction regions for total copy number 2 and 3 for the first
plate. Plotting symbols are the genotype calls (1=AA, 2=AB, 3=BB); light
grey points are from other plates. One could also add the prediction
regions for 0-4 copies, but it gets crowded.

<<genotypeCalls, fig=TRUE, width=8, height=8, include=FALSE, eval=FALSE>>=
xlim <- ylim <- c(6.5,13)
pch <- 21
colors <- c("red", "blue", "green3")
cex <- 0.6
par(mfrow=c(3,3), las=1, pty="s", ask=FALSE, mar=c(2, 2, 2, 2), oma=c(2, 2, 1, 1))
##plot 9 at a time
indices <- split(snpIndex(crlmmResults), rep(1:length(snpIndex(crlmmResults)), each=9, length.out=length(snpIndex(crlmmResults))))
par(ask=TRUE)
j <- 1
for(i in indices[[j]]){
	gt <- calls(crlmmResults)[i, ]
	plot(crlmmResults[i, ], 
	     pch=pch, 
	     col=colors[gt], 
	     bg=colors[gt], cex=cex,
	     xlim=xlim, ylim=ylim)
	mtext("A", 1, outer=TRUE, line=1)
	mtext("B", 2, outer=TRUE, line=1)	
}
@ 

<<predictionRegion, fig=TRUE, width=8, height=8, include=FALSE, eval=FALSE>>=
require(RColorBrewer)
greens <- brewer.pal(9, "Greens")
J <- split(1:ncol(cnset), cnset$batch)
colors <- c("red", "blue", "green3")
cex <- 0.6
colors <- c("blue", greens[8], "red")
pch.col <- c("grey40", "black", "grey40")
xlim <- ylim <- c(6.5,13)
plotpoints <- FALSE
lwd <- 2
pdf("figures/snp22plots%02d.pdf", width=600, height=600)
ask <- FALSE
par(mfrow=c(3,3), las=1, pty="s", ask=ask, mar=c(2, 2, 2, 2), oma=c(2, 2, 1, 1))
indices <- split(snpIndex(crlmmResults), rep(1:length(snpIndex(crlmmResults)), each=9, length.out=length(snpIndex(crlmmResults))))
for(j in seq(along=indices)[1:10]){
	cat(j, "\n")
	k <- 1
	for(i in indices[[j]]){
		gt <- calls(crlmmResults)[i, ]
		pch <- as.character(gt)
		cex <- 0.9
		plot(crlmmResults[i, ], 
		     pch=pch, 
		     col=pch.col[gt],
		     cex=cex,
		     xlim=xlim, ylim=ylim,
		     type="n")
		if(plotpoints){
			for(b in seq(along=unique(cnset$batch))){
				points(crlmmResults[i, J[[b]]], 
				       pch=pch, 
				       col=colors[b], bg=colors[b], cex=cex,
				       xlim=xlim, ylim=ylim)
			}
		}
		for(b in seq(along=unique(cnset$batch))){
			ellipse(cnset[i, J[[b]]], copynumber=2, col=colors[b], lwd=lwd)
		}
		##legend("bottomright", bty="n", legend=featureNames(crlmmResults)[i])
		if(k == 1) {
			legend("bottomleft", bty="n", fill=colors, legend=c("CEPH", "Yoruba", "Asian"))	
			mtext("A", 1, outer=TRUE, line=1)
			mtext("B", 2, outer=TRUE, line=0)			
		}
		k <- k+1
	}
}
dev.off()
@

<<problems, echo=FALSE, eval=FALSE>>=
##8300117, 8469401, 8706404, 2296864, 8659838, 1936806, 4198761, 8584395

@ 

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-predictionRegion}
  \caption{Prediction regions for copy number 2 for one SNP.  The
    plate effects are negligible for this SNP and we only plot the
    prediction region for the first plate.}
\end{figure}


\section{Smoothing via a hidden Markov model}

Here we smooth via a hidden Markov model.  To facilitate comparisons
with the Birdseye HMM, the same transition probabilities are specified.

<<segment>>=
library(VanillaICE)
copyNumberStates <- 0:5
require(Biobase)
cnset <- crlmm:::thresholdModelParams(cnset)
if(!exists("fit")){
	if(file.exists(file.path(outdir, paste("fit_", CHR, ".rda", sep="")))) load(file.path(outdir, paste("fit_", CHR, ".rda", sep="")))
	else {
		emission.cn <- computeEmission(crlmmResults, cnset, copyNumberStates)
		tau <- transitionProbability(chromosome=chromosome(cnset),
					     position=position(cnset),
					     TAUP=1e8)
		initialP <- rep(1/length(copyNumberStates), length(copyNumberStates))
		fit <- viterbi(initialStateProbs=log(initialP),
			       emission=emission.cn,
			       tau=tau[, "transitionPr"],
			       arm=tau[, "arm"], 
			       normalIndex=2,
			       normal2altered=0.005,
			       altered2normal=0.5,
			       altered2altered=0.0025)
		brks <- breaks(x=fit, states=copyNumberStates, position=tau[, "position"],
			       chromosome=tau[, "chromosome"],
			       sampleNames=sampleNames(cnset))
	}
}
@ 

<<visualizations, eval=FALSE>>=
dir.create("figures")
par(las=1, mfrow=c(1,1), ask=FALSE)
bmp("figures/chr22plots%02d.png", width=800, height=500)
for(j in 1:ncol(cnset)){
	cat(j, " ")
	##A region that we would miss if we only looked at the polymorphic probes...is it real?
	##index <- which(position(cnset) > 21.2*1e6 & position(cnset) < 21.6*1e6 & mns < 1)
	##fit <- fit[index,]
	index <- 1:nrow(fit)
	plot(0:1, type="n", xlim=range(position(cnset)[index]),
	     xaxt="n", ylim=c(-0.5, 6), 
	     ylab="copy number", xlab="physical position (Mb)",
	     main=paste(sampleNames(cnset)[j], ", CHR:", unique(chromosome(cnset))), 
	     lwd=2,
	     col="blue")
	points(position(cnset)[index], copyNumber(cnset)[index, j], pch=".", cex=2, col="grey60")
	lines(position(cnset)[index], fit[index, j]-1, type="s", lwd=2, col="blue")
	abline(h=0:4, col="grey60")
	axis(1, at=pretty(range(position(cnset)[index])), labels=pretty(range(position(cnset)[index]))/1e6)
}
dev.off()
@ 

<<fixProblems, eval=FALSE>>=
## NA18522, NA18978 (missed deletion), NA18944 (noisy), NA19098 and NA19130 (missed amplification), 
## NA19138 (looks like deletion with contamination), NA19143 (missed amplification)
## NA19204 (looks like homozygous deletion)
@ 

\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@ 


\end{document}
