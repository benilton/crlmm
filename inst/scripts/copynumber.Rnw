%\VignetteIndexEntry{crlmm copy number Vignette}
%\VignetteDepends{crlmm, genomewidesnp6Crlmm}
%\VignetteKeywords{crlmm, SNP 6}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\usepackage[margin=1in]{geometry}

\begin{document}
\title{Copy number estimation and genotype calling with \Rpackage{crlmm}}
\date{\today}
\author{Rob Scharpf}
\maketitle

<<setup, echo=FALSE, results=hide>>=
options(continue=" ", width=70)
@

%\section{Estimating copy number}

%At present, software for copy number estimation is provided only for the
%Affymetrix 6.0 platform.

\begin{abstract}
  This vignette estimates copy number for HapMap samples on the
  Affymetrix 6.0 platform.  See \citep{Scharpf2009} for the working
  paper.

\end{abstract}

\section{Simple usage}



<<cdfname>>=
library(crlmm)
@

Several genotyping platforms are currently supported.  Supported
platforms must have a corresponding annotation package (installed
separately) that are listed below.

<<annotationPackages>>=
annotationPackages()
@

Only the annotation package that end with the 'Crlmm' postfix are
supported for copy number estimation. For instance,
'pd.genomewidesnp6' and 'genomewidesnp6Crlmm' are both annotation
packages for the Affymetrix 6.0 platform, but the
'genomewidesnp6Crlmm' annotation package must be used for copy number
estimation.  The annotation package is specified through the 'cdfName'
-- the identifier without the 'Crlmm' postfix.  In the following code,
we specify the cdf name for Affymetrix 6.0, provide the complete path
to the CEL files, and indicate where intermediate files from the copy
number estimation are to be saved.

<<>>=
cdfName <- "genomewidesnp6"
pathToCels <- "/thumper/ctsa/snpmicroarray/hapmap/raw/affy/1m"
if(getRversion() < "2.12.0"){
	rpath <- getRversion()
} else rpath <- "trunk"
outdir <- paste("/thumper/ctsa/snpmicroarray/rs/ProcessedData/crlmm/", rpath, "/copynumber_vignette", sep="")
@

All long computations are saved in the output directory
\Robject{outdir}.  Users should change these variables as appropriate.
The following code chunk should fail unless the above arguments have
been set appropriately.

<<checkSetup>>=
if(!file.exists(outdir)) stop("Please specify a valid directory for storing output")
if(!file.exists(pathToCels)) stop("Please specify the correct path to the CEL files")
@

Processed data from codechunks requiring long computations are saved
to disk by wrapping function calls in the \Robject{checkExists}
function.  After running this vignette as a batch job, subsequent
calls to \verb@Sweave@ will load the saved computations from disk. For
additional information, see the examples in the help file for the
\Rfunction{checkExists} function.

\paragraph{Preprocessing and genotyping.}

In the following code chunk, we provide the complete path to the
Affymetrix CEL files and define a 'batch' variable. The
\Robject{batch} variable will be used to initialize a container for
storing the normalized intensities, the genotype calls, and the
parameter estimates for copy number.  Often the chemistry plate or the
scan date of the array is a useful surrogate for batch. For the HapMap
CEL files in our analysis, the CEPH (C) and Yoruban (Y) samples were
prepared on separate plates.  In the following code chunk, we extract
the population identifier from the CEL file names and use this as the
batch variable.

<<celfiles>>=
celFiles <- list.celfiles(pathToCels, full.names=TRUE, pattern=".CEL")
celFiles <- celFiles[substr(basename(celFiles), 13, 13) %in% c("C", "Y")]
batch <- as.factor(substr(basename(celFiles), 13, 13))
@

The preprocessing steps for copy number estimation includes quantile
normalization of the raw intensities for each probe and a step that
summarizes the intensities of multiple probes at a single locus.  For
example, the Affymetrix 6.0 platform has 3 or 4 identical probes at
each polymorphic locus and the normalized intensities are summarized
by a median.  For the nonpolymorphic markers on Affymetrix 6.0, only
one probe per locus is available and the summarization step is not
needed.

After preprocessing the arrays, the \crlmm{} package estimates the
genotype and provides a confidence score at each polymorphic locus.
Unless the dataset is small (e.g., fewer than 50 samples), we suggest
installing and loading the \R{} package \Rpackage{ff} to reduce the
RAM required for preprocessing and genotyping.  Loading the
\Rpackage{ff} package at this point will automatically enable large
data support (LDS).

The function \Rfunction{genotype} checks to see whether the
\Rpackage{ff} is loaded.  If loaded, the normalized intensities and
genotype are stored as \Robject{ff} objects on disk.  Otherwise, the
genotypes and normalized intensities are stored in matrices.  A word
of caution: the \Rfunction{genotype} function without \Rpackage{ff}
requires a potentially large amount of RAM.  Therefore, we illustrate
the \Robject{genotype} function using only the first 20 CEL files. We
wrap the function \Rfunction{genotype} in the \Rfunction{checkExists}
so that a user can load and inspect the saved object.  We first check
that the file \Robject{cnSet.rda} does not exist. Existence of this
file implies that we have already run the copy number estimation and,
therefore, we do not need to preprocess and genotype the files a
second time.

<<genotype>>=
tmpdir <- "~/tmp3"
stop()
##if(FALSE){
##if(file.exists(tmpdir)) unlink(tmpdir, recursive=TRUE)
dir.create(tmpdir)
##trace(genotype, browser)
system.time(gtSet2 <- genotype(filenames=celFiles[1:75],
			       cdfName=cdfName,
			       batch=batch[1:75]))
save(gtSet2, file=file.path(tmpdir, "gtSet2.rda"))
library(ff)
ldPath(tmpdir)
system.time(gtSet <- genotype(filenames=celFiles[1:75],
			      cdfName=cdfName,
			      batch=batch[1:75]))
save(gtSet, file=file.path(tmpdir, "gtSet.rda"))
q("no")
if(FALSE){
	library(ff)
	tmpdir <- "~/tmp"
	dir.create("~/tmp2")
	load(file.path(tmpdir, "gtSet.rda"))
	ldPath("~/tmp2")
	gtSet <- updateObject(gtSet) ## neeed to remove the old ff objects
	save(gtSet, file=file.path(ldPath(), "gtSet.rda"))
}

##trace(summarizeSnps, browser)
ocProbesets(100e3)
system.time(gtSet <- genotypeSummary(gtSet, GT.CONF.THR=0.95, type="SNP"))
system.time(gtSet <- genotypeSummary(gtSet, GT.CONF.THR=0.95, type="NP"))
system.time(gtSet <- genotypeSummary(gtSet, GT.CONF.THR=0.95, type="X.SNP"))
system.time(gtSet <- genotypeSummary(gtSet, GT.CONF.THR=0.95, type="X.NP"))
library(ff)
load("~/tmp2/gtSet.rda")
invisible(open(gtSet))
ocProbesets(100e3)

system.time(gtSet <- shrinkSummary(gtSet, type="SNP"))
##system.time(gtSet <- shrinkSummary(gtSet, type="NP"))
system.time(gtSet <- shrinkSummary(gtSet, type="X.SNP"))
##system.time(gtSet <- shrinkSummary(gtSet, type="X.NP"))

## test: try females only.  try males only

## fit linear model
##trace(crlmmCopynumber, browser)
##trace(fit.wls, browser)
trace(fit.lm1, browser)
system.time(cnSet <- crlmmCopynumber(gtSet, type="SNP"))
CA(cnSet)[1:5, 1:5]
totalCopyNumber(cnSet, i=1:5, j=1:5)

trace(fit.lm2, browser)
system.time(cnSet <- crlmmCopynumber(gtSet, type="NP"))
index <- which(!isSnp(cnSet))[1:10]
totalCopyNumber(cnSet, i=index, j=1:5)

##trace(fit.lm3, browser)
##trace(summarizeMaleXGenotypes, browser)
##trace(fit.wls, browser)
system.time(cnSet <- crlmmCopynumber(gtSet, type="X.SNP"))

trace(fit.lm4, browser)
system.time(cnSet <- crlmmCopynumber(gtSet, type="X.NP"))


Ns(gtSet, batchname="C")[1:5, ]
medians(gtSet, "A")[1:5, ]
mads(gtSet, "A")[1:5, ]
##log scale
tau2(gtSet, allele="A")[1:5, ]
tau2(gtSet, allele="B")[1:5, ]
corr(gtSet)[1:5, ]



cnSet <- crlmmCopynumber(gtSet, type="autosome.snps")






gtSet
tmp=Ns(gtSet)



NN <- N.AA(gtSet)[1:1000,]
N.AA(gtSet)[1:1000,] <- NN##do.call(cbind, lapply(NN, function(x) x[, 1]))


##tmp=Ns(gtSet)
##tmp <- Ns(gtSet, genotype="AA")
##tmp <- Ns(gtSet, genotype="AA", batchname="C")
##tmp <- Ns(gtSet,  batchname="C")
##Ns(gtSet, batchname="C") <- tmp

load(file.path(tmpdir, "gtSet2.rda"))
gtSet2.update <- updateObject(gtSet2)
isCurrent(gtSet2)








##using matrices
if(!file.exists(file.path(outdir, "cnSet.assayData_matrix.rda"))){
	gtSet <- checkExists("gtSet.assayData_matrix",
			     .path=outdir,
			     .FUN=genotype,
			     filenames=celFiles[1:20],
			     cdfName=cdfName,
			     batch=batch[1:20])
	class(calls(gtSet.assayData_matrix))
}
##q("no")
@

Next, we estimate copy number for the 20 CEL files.  The copy number
estimation step requirees a minimum number of CEL files in each batch
(we suggest 10).  While estimation can be performed using only the 20
samples as we do here, it would be far preferable to process all of
the files that were on the same chemistry plate.  The code chunk below
will load \Robject{cnSet.assayData_matrix} from disk if this

computation had already been performed as part of the batch job.

<<copynumber, eval=FALSE>>=
cnSet.assayData_matrix <- checkExists("cnSet.assayData_matrix",
				      .path=outdir,
				      .FUN=crlmmCopynumber,
				      object=gtSet.assayData_matrix,
				      chromosome=22)
@


A more memory efficient approach to preprocessing and genotyping is
implemented in the \R{} function \Rfunction{genotypeLD} and requires
the \Rpackage{ff} package.  The functions \Rfunction{ocProbesets} and
\Rfunction{ocSamples} can be used to manage how many probesets and
samples are to processed at a time and can therefore be used to fine
tune the required RAM.  The function \Rfunction{ldPath} indicates that
\Robject{ff} objects will be stored in the directory \Robject{outdir}.

<<ff>>=
library(ff)
ldPath(outdir)
ocProbesets(50000)
ocSamples(200)
@

With LDS now enabled, we preprocess and genotype 180 samples from the
CEPH and Yoruban populations using the \R{} function
\Robject{genotypeLD}.  Users that only want the genotypes at
polymorphic loci (and not the copy number estimates) should instead
use the \R{} function \Rfunction{crlmm} or \Rfunction{crlmm2}. Again,
we wrap the call to \Rfunction{genotypeLD} in \Rfunction{checkExists}
so that subsequent calls to \verb@Sweave@ can be run interactively.


<<LDS_genotype>>=
if(!file.exists(file.path(outdir, "cnSet.assayData_ff.rda"))){
	Rprof(filename="Rprof_genotypeff.out", interval=0.1)
	gtSet.assayData_ff <- checkExists("gtSet.assayData_ff",
					  .path=outdir,
					  .FUN=genotypeLD,
					  filenames=celFiles,
					  cdfName=cdfName,
					  batch=batch)
	Rprof(NULL)
	class(calls(gtSet.assayData_ff))
}
@

The analogous function for copy number estimation follows. In
practice, once the object \Robject{cnSet.assayData_ff} is created the
\Robject{gtSet.assayData_ff} is no longer needed and can be removed
from the \Robject{outdir}.

<<LDS_copynumber>>=
Rprof(filename="Rprof_cnff.out", interval=0.1)
##trace(fit.wls, browser)
cnSet.assayData_ff <- checkExists("cnSet.assayData_ff",
				  .path=outdir,
				  .FUN=crlmmCopynumberLD,
				  object=gtSet.assayData_ff)
Rprof(NULL)
##if(file.exists(file.path(outdir, "gtSet.assayData_ff.rda")))
##	unlink(file.path(outdir, "gtSet.assayData_ff.rda"))
gc()
q("no")
@

The objects returned by the \Rfunction{genotypeLD} and
\Rfunction{crlmmCopynumberLD} have assay data elements that are
pointers to \Robject{ff} objects stored in the directory
\Robject{outdir}.  The functions \Rfunction{open} and
\Rfunction{close} open and close the connections to the
\Robject{assayData} elements. Subsetting an \Robject{ff} object pulls
the data from disk into memory and should therefore be used with
caution. In particular, subsetting the \Robject{gt.assayData_ff} would
subset each elements in the \Robject{assayData} slot, returning an
object of the same class but with \Robject{assayData} elements that
are matrices.  Such an operation can be exceedingly slow and require
subsantial RAM.  The preferred approach is to extract only the assay
data element that is needed. In the example below, we extract the
genotype calls for the the first 50 samples.

<<check>>=
dims(cnSet.assayData_ff)
dims(cnSet.assayData_matrix)
print(object.size(cnSet.assayData_matrix), units="Mb")
print(object.size(cnSet.assayData_ff), units="Mb")
if(FALSE){
	replicate(5, system.time(gt1 <- calls(cnSet.assayData_matrix)[, 1:50])[[1]])
	open(calls(cnSet2))
	replicate(5, system.time(gt2 <- calls(cnSet.assayData_ff)[, 1:50])[[1]])
}
gt1 <- calls(cnSet.assayData_matrix)[, 1:50]
gt2 <- calls(cnSet.assayData_ff)[, 1:50]
all.equal(gt1, gt2)
@

Note that for the Affymetrix 6.0 platform the assay data elements each
have a row dimension corresponding to the total number of polymorphic
and nonpolymorphic markers interrogated by the Affymetrix 6.0
platform.  A consequence of keeping the rows of the assay data
elements the same for all of the statistical summaries is that the
matrix used to store genotype calls is larger than necessary.  Also,
note the additional overhead of some operations when using
\Robject{ff} objects.  For instance, the posterior probabilities for
the CRLMM genotype calls are represented as integers. The accessor
\Robject{snpCallProbability} can be used to access these confidence
scores.  When stored as matrices, converting the integer
representation back to the probability scale is straightforward as
shown below.  However, for the \Robject{ff} objects we must first
bring the data into memory. To bring all the scores into memory, one
could use the function \Rfunction{[,]} but this could be slow and
require a lot of RAM depending on the size of the dataset.  Instead,
we suggest pulling only the needed rows and columns from memory. In
the following example, we convert the integer scores to probabilities
for the CEPH samples.  As genotype confidence scores are not
applicable to the nonpolymorphic markers, we extract only the
polymorphic markers using the \Rfunction{isSnp} function.

<<assayData>>=
rows <- which(isSnp(cnSet))
cols <- which(batch == "C")
posterior.prob <- tryCatch(i2p(snpCallProbability(cnSet.assayData_ff)),
			    error=function(e) print("This will not work for an ff object."))
posterior.prob1 <- i2p(snpCallProbability(cnSet.assayData_matrix)[rows, cols])
posterior.prob2 <- i2p(snpCallProbability(cnSet.assayData_ff)[rows, cols])
all.equal(posterior.prob1, posterior.prob2)
@

Next, we obtain locus-level estimates of copy number by fitting a linear
model to each SNP. A variable named 'batch' must be indicated in the
\Robject{protocolData} of the \Robject{cnSet} object. As the inverse
variance of the within-genotype normalized intensities are used as
weights in the linear model (and hence the design matrix in the
regression changes for each SNP), the time is linear with the number of
markers on the array. Copy number estimation at nonpolymorphic markers
and polymorphic markers with unobserved genotypes is more difficult. We
refer the interested reader to the technical report \citep{Scharpf2009}.
Again, we peform the copy number estimation using the matrix version and
the ff version in parallel and encourage users with large datasets to
explore the latter. As with the preprocessing and genotyping, the
following code should be submitted as part of the batch job as it is too
slow for interactive analysis.

<<cn.ff, echo=FALSE, eval=FALSE>>=
rm(cnSet); gc()
ocProbesets(75e3)
##ff objects
system.time(cnSet2 <- crlmmCopynumber2(cnSet2))
save(cnSet2, file=file.path(outdir, "cnSet2.rda"))
@

<<timings, eval=FALSE>>=
tryCatch(print(paste("Time for matrix version:", time1)), error=function(e) print("timing for CN estimation not available"))
tryCatch(print(paste("Time for ff version:", time2)), error=function(e) print("timing for CN estimation not available"))
rm(cnSet2); gc()
@


\section{Accessors}

For the remainder of this vignette, we illustrate accessors and
visualizations using the sample object provided in the
\Rpackage{crlmm} package.

<<sampleset>>=
data(sample.CNSetLM)
x <- sample.CNSetLM
@


\subsection{Quantile-normalized intensities}

Accessors for the quantile normalized intensities for the A allele at
polymorphic loci:

<<accessors>>=
snp.index <- which(isSnp(x))
np.index <- which(!isSnp(x))
a <- (A(x))[snp.index, ]
dim(a)
@

The extra set of parentheses surrounding \Robject{A(cnSet2)} above is
added to emphasize the appropriate order of operations. Subsetting the
entire \Robject{x} object in the following code should be avoided for
large datasets.

<<eval=FALSE>>=
a <- A(x[snp.index, ])
@

The quantile-normalized intensities for nonpolymorphic loci are obtained
by:

<<>>=
npIntensities <- (A(x))[np.index, ]
@

Quantile normalized intensities for the B allele at polymorphic loci:

<<B.polymorphic>>=
b.snps <- (B(x))[snp.index, ]
@

Note that NAs are recorded in the 'B' assay data element for
nonpolymorphic loci:

<<B.NAs>>=
all(is.na((B(x))[np.index, ]))
@

<<clean, echo=FALSE>>=
rm(b.snps, a, npIntensities); gc()
@

\paragraph{\Robject{SnpSet}: Genotype calls and confidence scores}

Genotype calls:
<<genotypes>>=
genotypes <- (snpCall(x))[snp.index, ]
@
Confidence scores of the genotype calls:
<<confidenceScores>>=
genotypeConf <- integerScoreToProbability(snpCallProbability(x)[snp.index[1:10], ])
@

\paragraph{\Robject{CopyNumberSet}: allele-specific copy number}

Allele-specific copy number at polymorphic loci:
<<ca>>=
##ca <- CA(x[snp.index, ])/100
snp.index <- which(isSnp(x))
ca <- CA(x, i=snp.index)
##or
ca <- ACN(x, "A", i=snp.index)
cb <- CB(x, i=snp.index)
ct <- ca+cb
@

Total copy number at nonpolymorphic loci:
<<ca>>=
cn.nonpolymorphic <- CA(obj, i=which(!isSnp(obj)))
@

Total copy number at both polymorphic and nonpolymorphic loci:
<<totalCopynumber>>=
##cn <- copyNumber(x)
cn <- totalCopyNumber(x, sample(1:nrow(x), 1e4), 1:5)
apply(cn, 2, median, na.rm=TRUE)
@

\subsection{Other accessors}

Information on physical position and chromosome can be accessed as follows:

<<positionChromosome>>=
xx <- position(x)
yy <- chromosome(x)
@

Parameters from the linear model used to estimate copy number are
stored in the slot \Robject{lM}.

<<copynumberParameters>>=
names(lM(x))
dim(lM(x)[[1]])
@



\section{Suggested visualizations}

\paragraph{SNR.}

A histogram of the signal to noise ratio for the HapMap samples:

<<plotSnr, fig=TRUE, include=FALSE>>=
hist(x$SNR, xlab="SNR", main="", breaks=25)
@

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{copynumber-plotSnr}
  \caption{Signal to noise ratios for the HapMap samples.}
\end{figure}



\paragraph{One sample at a time: locus-level estimates}

Figure \ref{fig:oneSample} plots physical position (horizontal axis)
versus copy number (vertical axis) for the first sample.  There is less
information to estimate copy number at nonpolymorphic loci; improvements
to the univariate prediction regions at nonpolymorphic loci are a future
area of research.

<<oneSample, fig=TRUE, width=8, height=4, include=FALSE>>=
par(las=1, mar=c(4, 5, 4, 2))
plot(position(x), copyNumber(x)[, 1], pch=".",
     cex=2, xaxt="n", col="grey20", ylim=c(0,4),
     ylab="copy number", xlab="physical position (Mb)",
     main=paste(sampleNames(x)[1], ", CHR:", unique(chromosome(x))))
points(position(x)[!isSnp(x)], copyNumber(x)[!isSnp(x), 1],
       pch=".", cex=2, col="lightblue")
axis(1, at=pretty(range(position(x))), labels=pretty(range(position(x)))/1e6)
@

<<idiogram, eval=FALSE, echo=FALSE>>=
require(SNPchip)
plotCytoband(22, new=FALSE, cytoband.ycoords=c(3.8, 4), label.cytoband=FALSE)
@

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-oneSample}
  \caption{\label{fig:oneSample} Total copy number (y-axis) for
    chromosome 1 plotted against physical position (x-axis) for one
    sample.  Estimates at nonpolymorphic loci are plotted in light
    blue.}
\end{figure}

%
%<<overlayHmmPredictions, fig=TRUE, include=FALSE>>=
%ask <- FALSE
%op <- par(mfrow=c(3, 1), las=1, mar=c(1, 4, 1, 1), oma=c(3, 1, 1, 1), ask=ask)
%##Put fit on the copy number scale
%cns <- copyNumber(cnSet2)
%cnState <- hmmPredictions - as.integer(1)
%xlim <- c(10*1e6, max(position(cnSet2)))
%cols <- brewer.pal(8, "Dark2")[1:4]
%for(j in 1:3){
%	plot(position(cnSet2), cnState[, j], pch=".", col=cols[2], xaxt="n",
%	     ylab="copy number", xlab="Physical position (Mb)", type="s", lwd=2,
%	     ylim=c(0,6), xlim=xlim)
%	points(position(cnSet2), cns[, j], pch=".", col=cols[3])
%	lines(position(cnSet2), cnState[,j], lwd=2, col=cols[2])
%	axis(1, at=pretty(position(cnSet)),
%	     labels=pretty(position(cnSet))/1e6)
%	abline(h=c(1,3), lty=2, col=cols[1])
%	legend("topright", bty="n", legend=sampleNames(cnSet)[j])
%	legend("topleft", lty=1, col=cols[2], legend="copy number state",
%	       bty="n", lwd=2)
%	plotCytoband(CHR, cytoband.ycoords=c(5, 5.2), new=FALSE,
%		     label.cytoband=FALSE, xlim=xlim)
%}
%par(op)
%@
%
%\begin{figure}
%  \includegraphics[width=\textwidth]{copynumber-overlayHmmPredictions}
%  \caption{\label{fig:overlayHmmPredictions} Total copy number (y-axis)
%    for chromosome 22 plotted against physical position (x-axis) for
%    three samples.  Estimates at nonpolymorphic loci are plotted in
%    light blue. }
%\end{figure}

\clearpage
\paragraph{One SNP at a time}

Scatterplots of the A and B allele intensities (log-scale) can be
useful for assessing the biallelic genotype calls.  This section of
the vignette is currently under development.
% The following code chunk is
%displayed in Figure \ref{fig:prediction}.

<<predictionRegions, fig=TRUE, width=8, height=8, include=FALSE, eval=FALSE>>=
i <- snp.index[1]
#plotCNSetLM=crlmm:::plotCNSetLM
##trace(plotCNSetLM, browser)
plot(i, x, copynumber=2)
##myScatter <- function(object, add=FALSE, ...){
##	A <- log2(A(object))
##	B <- log2(B(object))
##	if(!add){
##		plot(A, B, ...)
##	} else{
##		points(A, B, ...)
##	}
##}
##index <- which(isSnp(cnSet))[1:9]
##xlim <- ylim <- c(6.5,13)
##par(mfrow=c(3,3), las=1, pty="s", ask=FALSE, mar=c(2, 2, 2, 2), oma=c(2, 2, 1, 1))
##for(i in index){
##	gt <- calls(cnSet)[i, ]
##	if(i != 89){
##		myScatter(cnSet[i, ],
##			  pch=pch,
##			  col=colors[snpCall(cnSet)[i, ]],
##			  bg=colors[snpCall(cnSet)[i, ]], cex=cex,
##			  xlim=xlim, ylim=ylim)
##		mtext("A", 1, outer=TRUE, line=1)
##		mtext("B", 2, outer=TRUE, line=1)
##		crlmm:::ellipse.CNSet(cnSet[i, ], copynumber=2, batch="C", lwd=2, col="black")
##		crlmm:::ellipse.CNSet(cnSet[i, ], copynumber=2, batch="Y", lwd=2, col="grey50")
##	} else {
##		plot(0:1, xlim=c(0,1), ylim=c(0,1), type="n", xaxt="n", yaxt="n")
##		legend("center",
##		       legend=c("CN = 2, CEPH", "CN = 2, Yoruban"),
##		       col=c("black", "grey50"), lwd=2, bty="n")
##	}
##}
@

%\begin{figure}
%  \centering
%  \includegraphics[width=0.8\textwidth]{copynumber-predictionRegions}
%  \caption{\label{fig:prediction} Scatterplots of A versus B
%    intensities.  Each panel displays a single SNP. The ellipses
%    indicate the 95\% probability region for copy number 2 for the CEPH
%    (black) and Yoruban subjects (grey).}
%\end{figure}

%\section{Details for the copy number estimation procedure}
%
%See the technical report \citep{Scharpf2009}.

\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@

\section*{References}

%\begin{bibliography}
  \bibliographystyle{plain}
  \bibliography{refs}
%\end{bibliography}


\end{document}
