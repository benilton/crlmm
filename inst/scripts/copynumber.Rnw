%\VignetteIndexEntry{crlmm copy number Vignette}
%\VignetteDepends{crlmm, genomewidesnp6Crlmm}
%\VignetteKeywords{crlmm, SNP 6}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}

\begin{document}
\title{Estimating copy number for Affymetrix 6.0  with the crlmm Package}
\date{February, 2009}
\author{Rob Scharpf}
\maketitle

<<setup, echo=FALSE, results=hide>>=
options(width=60)
options(continue=" ")
options(prompt="R> ")
@ 

\section{Estimating copy number}

At present, software for copy number estimation is provided only for
the Affymetrix 6.0 platform.  This vignette estimates copy number for
the HapMap samples.

\subsection{Preprocess and genotype the samples}

See the crlmm vignette for additional details on
preprocessing/genotyping.  

<<requiredPackages>>=
library(crlmm)
library(genomewidesnp6Crlmm)
library(ellipse)
@ 

You must specify the names of the CEL files and the full path, as well
as a directory in which to store the output from crlmm and cnrma.

<<celfiles>>=
celFiles <- list.celfiles("/thumper/ctsa/snpmicroarray/hapmap/raw/affy/1m", full.names=TRUE, pattern=".CEL")
outdir <- "/thumper/ctsa/snpmicroarray/rs/data/hapmap/1m/affy"
@ 

Preprocess and genotype (for more info see the crlmm vignette).

<<genotype>>=
if (!exists("crlmmResult")) {
	if (file.exists(file.path(outdir, "crlmmResult.rda"))){
		load(file.path(outdir, "intensities.rda"))
		load(file.path(outdir, "crlmmResult.rda"))
	}
	else {
		crlmmResult <- crlmm(celFiles, save.it=TRUE, intensityFile=file.path(outdir, "intensities.rda"))
		save(crlmmResult, file=file.path(outdir, "crlmmResult.rda"))
	}
}
@ 

Quantile normalize the nonpolymorphic probes and save the results.

<<cnrma>>=
if(!exists("cnrmaResult")){
	if(file.exists(file.path(outdir, "cnrmaResult.rda"))) load(file.path(outdir, "cnrmaResult.rda"))
	else {
		cnrmaResult <- cnrma(celFiles)
		save(cnrmaResult, file=file.path(outdir, "cnrmaResult.rda"))
	}
}
@ 

\subsection{Copy number}
<<chr>>=
CHR <- 21
@ 

Copy number can be assessed one chromosome at a time.  Here we specify
chromosome \Sexpr{CHR} and and load a list of indices to subset the data. The
first element in the list correspond to indices of polymorphic probes
on chromosome \Sexpr{CHR}; the second element corresponds to indices of
nonpolymorphic probes on chromosome \Sexpr{21}.

<<chromosomeIndex>>=
CHR_INDEX <- paste(CHR, "index", sep="")
data(list=CHR_INDEX, package="genomewidesnp6Crlmm")
str(index)
@ 

We require 6 items for copy number estimation:

\begin{itemize}
  \item quantile-normalized A intensities (I1 x J)
  \item quantile-normalized B intensities (I1 x J)
  \item quantile-normalized intensities from nonpolymorphic (NP) probes (I2 x J)
  \item genotype calls (I1 x J)
  \item confidence scores of the genotype calls  (I1 x J)
  \item signal to noise ratio (SNR) of the samples (J)
  \end{itemize}
  
  These items are extracted as follows:

<<snpAndCnSummaries>>=
A <- res$A
B <- res$B
calls <- crlmmResult$calls
conf <- crlmmResult$conf
SNR <- crlmmResult$SNR
NP <- cnrmaResult$NP
gc()
@ 

Make a histogram of the signal to noise ratio for these samples:

<<plotSnr, fig=TRUE>>=
hist(SNR, xlab="SNR", main="")
@ 

We suggest excluding samples with a signal to noise ratio less than 5.
We then extract the probes (rows) that are on chromosome 15 and the
samples (columns) that have a suitable signal to noise ratio.

<<subsetCrlmmOutput>>=
A <- A[index[[1]], SNR > 5]
B <- B[index[[1]], SNR > 5]
calls <- calls[index[[1]], SNR > 5]
conf <- conf[index[[1]], SNR > 5]
NP <- NP[index[[2]], SNR > 5]
@ 

Batch effects can be very large in the quantile-normalized
intensities.  Often the chemistry plate is a good surrogate for batch
effects, although it can also be the lab, etc.  Here we define batch
by the chemistry plate. For the HapMap data, plate is often confounded
with ancestry.

<<specifyBatch>>=
sns <- colnames(calls)
sns[1]
plate <- substr(basename(sns), 13, 13)
table(plate)
@ 

We are now ready to estimate copy number for each batch.  In the
current version of this package, one specifies an environment to which
intermediate \R{} objects for copy number estimation are
stored. Allele-specific estimates of copy number are also stored in
this environment.

<<copyNumberByBatch>>=
if(!exists("e1")){
	e1 <- new.env()
	computeCopynumber(A=A,
			  B=B,
			  calls=calls,
			  conf=conf,
			  NP=NP,
			  plate=plate,
			  envir=e1, chrom=CHR, DF.PRIOR=75)
}
@ 

The DF.PRIOR indicates how much we will shrink SNP-specific estimates
of the variance and correlation.

<<accessingEstimates>>=
copyA <- get("CA", e1)
copyB <- get("CB", e1)
copyT <- (copyA+copyB)/100
copyT[copyT < 0] <- 0
copyT[copyT > 6] <- 6
@ 

\section{Suggested plots}

\paragraph{One sample at a time}

<<annotation>>=
data(snpProbes, package="genomewidesnp6Crlmm")
data(cnProbes, package="genomewidesnp6Crlmm")
position <- snpProbes[match(rownames(calls), rownames(snpProbes)), "position"]
@ 

To plot physical position versus copy number for the first sample:

<<oneSample, fig=TRUE, width=8, height=4, include=FALSE>>=
require(SNPchip)
par(las=1)
plotCytoband(as.character(CHR), ylim=c(0,7), cytoband.ycoords=c(6.5,7), label.cytoband=FALSE, main="Chr 15")
points(position, copyT[, 1], pch=".", cex=2, , xaxt="n", col="grey70")
axis(1, at=pretty(range(position)), labels=pretty(range(position))/1e6)
axis(2, at=0:5, labels=0:5)
mtext("position (Mb)", 1, line=2)
mtext(expression(hat(C)[A] + hat(C)[B]), 2, line=2, las=3)
@ 

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-oneSample}
  \caption{Total copy number (y-axis) for chromosome 22 plotted
    against physical position (x-axis) for one sample.  }
\end{figure}

\paragraph{One SNP at a time}

This section needs to be cleaned up (TODO).

<<intermediateFiles>>=
tau2A <- get("tau2A", e1)
tau2B <- get("tau2B", e1)
sig2A <- get("sig2A", e1)
sig2B <- get("sig2B", e1)
nuA <- get("nuA", e1)
phiA <- get("phiA", e1)
nuB <- get("nuB", e1)
phiB <- get("phiB", e1)
corr <- get("corr", e1)
corrA.BB <- get("corrA.BB", e1)
corrB.AA <- get("corrA.BB", e1)
A <- get("A", e1)
B <- get("B", e1)
@ 

Here, we plot the prediction regions for total copy number 2 and 3 for
the first plate. Plotting symbols are the genotype calls (1=AA, 2=AB,
3=BB); light grey points are from other plates. (You could also add
the prediction regions for 0-4 copies, but it gets crowded).  Notice
that there is little evidence of a plate effect for this SNP.

<<predictionRegion, fig=TRUE, width=8, height=8, include=FALSE>>=
par(las=1, pty="s")
p <- 1 ##indicates plate
J <- grep(unique(plate)[p], plate) ##sample indices for this plate
ylim <- c(6.5,13)
I <- which(phiA > 10 & phiB > 10)
i <- I[1]
##plate effects are small
log2(phiA[i, ])
log2(phiB[i, ])
plot(log2(A[i, ]), log2(B[i, ]), pch=as.character(calls[i, ]), col="grey60", cex=0.9, ylim=ylim, xlim=ylim, xlab="A", ylab="B")
points(log2(A[i, J]), log2(B[i, J]), col="black", pch=as.character(calls[i, J]))
for(CT in 2){
	if(CT == 2) ellipse.col <- "black" ##else ellipse.col <- "purple"
	for(CA in 0:CT){
		CB <- CT-CA
		A.scale <- sqrt(tau2A[i, p]*(CA==0) + sig2A[i, p]*(CA > 0))
		B.scale <- sqrt(tau2B[i, p]*(CB==0) + sig2B[i, p]*(CB > 0))
		scale <- c(A.scale, B.scale)
		if(CA == 0 & CB > 0) rho <- corrA.BB[i, p]
		if(CA > 0 & CB == 0) rho <- corrB.AA[i, p]
		if(CA > 0 & CB > 0) rho <- corr[i, p]		
		lines(ellipse(x=rho, centre=c(log2(nuA[i, p]+CA*phiA[i, p]), log2(nuB[i, p]+CB*phiB[i, p])),
			      scale=scale), col=ellipse.col, lwd=2)
	}
}
legend("topright", lwd=3, col="black", legend="2 copies", bty="n")
@ 

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-predictionRegion}
  \caption{Prediction regions for copy number 2 for one SNP.  The
    plate effects are negligible for this SNP and we only plot the
    prediction region for the first plate.}
\end{figure}


<<predictionRegion, eval=FALSE>>=
par(las=1, pty="s", ask=TRUE)
p <- 1 ##indicates plate
J <- grep(unique(plate)[p], plate) ##sample indices for this plate
ylim <- c(6.5,13)
I <- which(phiA > 10 & phiB > 10)
col <- c("grey0", "grey30", "grey70")
cex <- 3
for(j in seq(along=I)){
	i <- I[j]
	J1 <- grep("C", plate) ##sample indices for this plate
	J2 <- grep("Y", plate) ##sample indices for this plate	
	J3 <- grep("A", plate)
	plot(log2(A[i, ]), log2(B[i, ]), pch=21, col="grey60", type="n", cex=0.9, ylim=ylim, xlim=ylim, xlab="A", ylab="B")
	points(log2(A[i, J1]), log2(B[i, J1]), col=col[1], pch=".", cex=cex)
	points(log2(A[i, J2]), log2(B[i, J2]), col=col[2], pch=".", cex=cex)
	points(log2(A[i, J3]), log2(B[i, J3]), col=col[3], pch=".", cex=cex)
	P <- 1:3
	ellipse.col <- col
	for(p in seq(along=P)){
		for(CT in 2){
			for(CA in 0:CT){
				CB <- CT-CA
				A.scale <- sqrt(tau2A[i, p]*(CA==0) + sig2A[i, p]*(CA > 0))
				B.scale <- sqrt(tau2B[i, p]*(CB==0) + sig2B[i, p]*(CB > 0))
				scale <- c(A.scale, B.scale)
				if(CA == 0 & CB > 0) rho <- corrA.BB[i, p]
				if(CA > 0 & CB == 0) rho <- corrB.AA[i, p]
				if(CA > 0 & CB > 0) rho <- corr[i, p]		
				lines(ellipse(x=rho, centre=c(log2(nuA[i, p]+CA*phiA[i, p]), log2(nuB[i, p]+CB*phiB[i, p])),
					      scale=scale), col=ellipse.col[p], lwd=2)
			}
		}

	}
	legend("topright", lwd=3, col=ellipse.col, legend=unique(plate), bty="n")	
}
@ 

Look at the distribution of shifts in the predicted centers across the
plates.  The biggest shifts are for SNPs that have no observations in
a subset of the plates.  Here, we should borrow strength across plates
to improve the prediction regions (TO DO).

<<shifts, eval=FALSE>>=
shiftA <- log2(nuA+phiA)
maxA <- apply(shiftA, 1, max, na.rm=TRUE)
minA <- apply(shiftA, 1, min, na.rm=TRUE)
d <- maxA - minA
hist(d)
index <- which(d > 1)
plate1 <- plate2 <- rep(NA, length(index))
for(i in seq(along=index)){
	plate1[i] <- which(shiftA[index[i], ] == maxA[index[i]])
	plate2[i] <- which(shiftA[index[i], ] == minA[index[i]])
}

par(las=1)
for(j in seq(along=index)){
	i <- index[j]
	J1 <- grep(plate[plate1[j]], plate) ##sample indices for this plate
	J2 <- grep(plate[plate2[j]], plate) ##sample indices for this plate
	ylim <- c(6.5,13)
	plot(log2(A[i, ]), log2(B[i, ]), pch=as.character(calls[i, ]), col="grey60", cex=0.9, ylim=ylim, xlim=ylim, xlab="A", ylab="B")
	points(log2(A[i, J1]), log2(B[i, J1]), col="brown", pch=as.character(calls[i, J1]))
	points(log2(A[i, J2]), log2(B[i, J2]), col="blue", pch=as.character(calls[i, J2]))
	CT <- 2
	P <- c(plate1[j], plate2[j])
	for(p in seq(along=P)){
		if(p == 1) ellipse.col="brown" else ellipse.col="blue"
		for(CA in 0:CT){
			CB <- CT-CA
			A.scale <- sqrt(tau2A[i, p]*(CA==0) + sig2A[i, p]*(CA > 0))
			B.scale <- sqrt(tau2B[i, p]*(CB==0) + sig2B[i, p]*(CB > 0))
			scale <- c(A.scale, B.scale)
			if(CA == 0 & CB > 0) rho <- corrA.BB[i, p]
			if(CA > 0 & CB == 0) rho <- corrB.AA[i, p]
			if(CA > 0 & CB > 0) rho <- corr[i, p]			
			lines(ellipse(x=rho, centre=c(log2(nuA[i, p]+CA*phiA[i, p]), log2(nuB[i, p]+CB*phiB[i, p])),
				      scale=scale), col=ellipse.col, lwd=2)
		}
	}
}
legend("topright", lwd=3, col=c("brown", "blue"), legend=c("2 copies, plate 1", "2 copies, plate 2 "), bty="n")
@ 

Now look at shifts for which we have at least 3 observations in each
genotype cluster (TO DO).

<<shifts, eval=FALSE, echo=FALSE>>=
shiftA <- log2(nuA+phiA)
maxA <- apply(shiftA, 1, max, na.rm=TRUE)
minA <- apply(shiftA, 1, min, na.rm=TRUE)
d <- maxA - minA
hist(d)
index <- which(d > 0.2)
plate1 <- plate2 <- rep(NA, length(index))
for(i in seq(along=index)){
	plate1[i] <- which(shiftA[index[i], ] == maxA[index[i]])
	plate2[i] <- which(shiftA[index[i], ] == minA[index[i]])
}
@ 

%\begin{figure}
%  \includegraphics[width=0.9\textwidth]{copynumber-plateEffect}
%  \caption{The prediction regions for copy number 2 shift when there
%    is a large plate effect.}
%\end{figure}

\section{Session information}
<<>>=
sessionInfo()
@ 


\end{document}
