%\VignetteIndexEntry{crlmm copy number Vignette}
%\VignetteDepends{crlmm, genomewidesnp6Crlmm}
%\VignetteKeywords{crlmm, SNP 6}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\usepackage[margin=1in]{geometry}

\begin{document}
\title{Copy number estimation and genotype calling with \Rpackage{crlmm}}
\date{\today}
\author{Rob Scharpf}
\maketitle

<<setup, echo=FALSE, results=hide>>=
options(continue=" ", width=70)
@ 

%\section{Estimating copy number}

%At present, software for copy number estimation is provided only for the
%Affymetrix 6.0 platform.  

\begin{abstract}
  This vignette estimates copy number for HapMap samples on the
  Affymetrix 6.0 platform.  See \citep{Scharpf2009} for the working
  paper.
  
\end{abstract}

\section{Simple usage}

CRLMM supports the following platforms:

<<cdfname>>=
library(oligoClasses)
library(crlmm)
crlmm:::validCdfNames()
cdfName <- "genomewidesnp6"
pathToCels <- "/thumper/ctsa/snpmicroarray/hapmap/raw/affy/1m"
if(getRversion() < "2.12.0"){
	rpath <- getRversion()
} else rpath <- "trunk"
outdir <- paste("/thumper/ctsa/snpmicroarray/rs/ProcessedData/crlmm/", rpath, "/copynumber_vignette", sep="")
@ 

\paragraph{About this vignette.} This vignette was created using CEL
files that are located in a specific directory on my computer
(\Robject{pathToCels}).  Long computations are saved in the output
directory \Robject{outdir}.  Users should change these variables as
appropriate.  The following code chunk should fail unless the above
arguments have been set appropriately.

<<checkSetup>>=
if(!file.exists(outdir)) stop("Please specify valid directory for storing output")
if(!file.exists(pathToCels)) stop("Please specify the correct path to the CEL files")
@ 

Processed data from codechunks requiring long computations are saved
to disk automatically by wrapping function calls in the
\Robject{checkExists} function.  After the initial batch job,
subsequent calls to \verb@Sweave@ will load saved computations from
disk and can therefore be run interactively. This may be useful as you
begin to explore some of the tools for accessing processed data and
visualizations.

\paragraph{Preprocessing and genotyping.}

In the following code chunk, we provide the complete path to the
Affymetrix CEL files and define a 'batch' variable. The
\Robject{batch} variable will later be useful when we estimate copy
number.  We typically use the 96 well chemistry plate or the scan date
of the array as a surrogate for batch. Adjusting by date or chemistry
plate can be critical for limiting the influence of batch effects. For
the HapMap CEL files in our analysis, the CEPH (C) and Yoruban (Y)
samples were run on separate plates and can be extracted from the CEL
filename as below.  

<<celfiles>>=
celFiles <- list.celfiles(pathToCels, full.names=TRUE, pattern=".CEL")
if(length(celFiles) < 1) stop("Please specify the appropriate path to CEL files")
## CEPH and Yoruban
batch <- substr(basename(celFiles), 13, 13)
celFiles <- celFiles[batch %in% c("C", "Y")]
batch <- batch[batch %in% c("C", "Y")]
stopifnot(length(batch) == length(celFiles))
@ 

The preprocessing steps for copy number estimation includes quantile
normalization of the polymorphic and nonpolymorphic markers and a
summarization step whereby the quantile normalized intenities are
summarized for each locus.  As the markers at polymorphic loci on the
Affymetrix 6.0 platform are identical, we summarize the intensities by
the median. For the nonpolymorphic markers, no summarization step is
performs.  Next, the \crlmm{} package provides a genotype call and a
confidence score at each polymorphic locus.  Unless the dataset is
small (e.g., fewer than 50 samples), we suggest installing and loading
the \R{} package \Rpackage{ff}.  The function \Rfunction{genotype}
checks to see whether the \Rpackage{ff} is loaded.  If loaded, the
normalized intensities and genotype are stored as \Robject{ff} objects
on disk.  Otherwise, the genotypes and normalized intensities are
stored in matrices.  A word of caution: the \Rfunction{genotype}
function without \Rpackage{ff} requires a potentially large amount of
RAM.  Therefore, we illustrate the \Robject{genotype} function using
only the first 20 CEL files. We wrap the function \Rfunction{genotype}
in the \Rfunction{checkExists} so that a user can load and inspect the
saved object.  We first check that the file \Robject{cnSet.rda} does
not exist. Existence of this file implies that we have already run the
copy number estimation and, therefore, we do not need to preprocess
and genotype the files a second time.

<<genotype>>=
if(!file.exists(file.path(outdir, "cnSet.rda"))){
	gtSet.assayData_matrix <- checkExists("gtSet.assayData_matrix",
					   .path=outdir,
					   .FUN=genotype,
					   filenames=celFiles[1:20],
					   cdfName=cdfName,
					   batch=batch[1:20])
	class(calls(gtSet.assayData_matrix))
}
##q("no")
@ 

Next, we estimate copy number for the 20 CEL files.  The copy number
estimation step requirees a minimum number of CEL files in each batch
(we suggest 10).  While estimation can be performed using only the 20
samples as we do here, it would be far preferable to process all of
the files that were on the same chemistry plate.  The code chunk below
will load \Robject{cnSet.assayData_matrix} from disk if this
computation had already been performed as part of the batch job.

<<copynumber>>=
cnSet.assayData_matrix <- checkExists("cnSet.assayData_matrix",
				      .path=outdir,
				      .FUN=crlmmCopynumber,
				      object=gtSet.assayData_matrix,
				      chromosome=22)
##Rprof(interval=0.1)
obj <- crlmmCopynumber(gtSet.assayData_matrix, chromosome=23)
if(file.exists(file.path(outdir, "gtSet.assayData_matrix.rda")))
	unlink(file.path(outdir, "gtSet.assayData_matrix.rda"))
@ 


A more memory efficient approach to preprocessing and genotyping is
implemented in the \R{} function \Rfunction{genotypeLD} and requires
the \Rpackage{ff} package.  The functions \Rfunction{ocProbesets} and
\Rfunction{ocSamples} can be used to manage how many probesets and
samples are to processed at a time and can therefore be used to fine
tune the required RAM.  The function \Rfunction{ldPath} indicates that
\Robject{ff} objects will be stored in the directory \Robject{outdir}.

<<ff>>=
library(ff)
ldPath(outdir)
ocProbesets(50000)
ocSamples(200)
@ 

With LDS now enabled, we preprocess and genotype 180 samples from the
CEPH and Yoruban populations using the \R{} function
\Robject{genotypeLD}.  Users that only want the genotypes at
polymorphic loci (and not the copy number estimates) should instead
use the \R{} function \Rfunction{crlmm} or \Rfunction{crlmm2}. Again,
we wrap the call to \Rfunction{genotypeLD} in \Rfunction{checkExists}
so that subsequent calls to \verb@Sweave@ can be run interactively. 


<<LDS_genotype>>=
if(!file.exists(file.path(outdir, "cnSet.assayData_ff.rda"))){
	Rprof(filename="Rprof_genotypeff.out", interval=0.1)
	gtSet.assayData_ff <- checkExists("gtSet.assayData_ff",
					  .path=outdir,
					  .FUN=genotypeLD,
					  filenames=celFiles,
					  cdfName=cdfName,
					  batch=batch)
	Rprof(NULL)
	class(calls(gtSet.assayData_ff))
}
@ 

The analogous function for copy number estimation follows. In
practice, once the object \Robject{cnSet.assayData_ff} is created the
\Robject{gtSet.assayData_ff} is no longer needed and can be removed
from the \Robject{outdir}.

<<LDS_copynumber>>=
Rprof(filename="Rprof_cnff.out", interval=0.1)
cnSet.assayData_ff <- checkExists("cnSet.assayData_ff",
				  .path=outdir,
				  .FUN=crlmmCopynumberLD,
				  filenames=celFiles,
				  cdfName=cdfName,
				  batch=batch)
Rprof(NULL)
if(file.exists(file.path(outdir, "gtSet.assayData_ff.rda")))
	unlink(file.path(outdir, "gtSet.assayData_ff.rda"))
gc()
@ 

The objects returned by the \Rfunction{genotypeLD} and
\Rfunction{crlmmCopynumberLD} have assay data elements that are
pointers to \Robject{ff} objects stored in the directory
\Robject{outdir}.  The functions \Rfunction{open} and
\Rfunction{close} open and close the connections to the
\Robject{assayData} elements. Subsetting an \Robject{ff} object pulls
the data from disk into memory and should therefore be used with
caution. In particular, subsetting the \Robject{gt.assayData_ff} would
subset each elements in the \Robject{assayData} slot, returning an
object of the same class but with \Robject{assayData} elements that
are matrices.  Such an operation can be exceedingly slow and require
subsantial RAM.  The preferred approach is to extract only the assay
data element that is needed. In the example below, we extract the
genotype calls for the the first 50 samples.

<<check>>=
dims(cnSet.assayData_ff)
dims(cnSet.assayData_matrix)
print(object.size(cnSet.assayData_matrix), units="Mb")
print(object.size(cnSet.assayData_ff), units="Mb")
if(FALSE){
	replicate(5, system.time(gt1 <- calls(cnSet.assayData_matrix)[, 1:50])[[1]])
	open(calls(cnSet2))
	replicate(5, system.time(gt2 <- calls(cnSet.assayData_ff)[, 1:50])[[1]])
}
gt1 <- calls(cnSet.assayData_matrix)[, 1:50]
gt2 <- calls(cnSet.assayData_ff)[, 1:50]
all.equal(gt1, gt2)
@ 

Note that for the Affymetrix 6.0 platform the assay data elements each
have a row dimension corresponding to the total number of polymorphic
and nonpolymorphic markers interrogated by the Affymetrix 6.0
platform.  A consequence of keeping the rows of the assay data
elements the same for all of the statistical summaries is that the
matrix used to store genotype calls is larger than necessary.  Also,
note the additional overhead of some operations when using
\Robject{ff} objects.  For instance, the posterior probabilities for
the CRLMM genotype calls are represented as integers. The accessor
\Robject{snpCallProbability} can be used to access these confidence
scores.  When stored as matrices, converting the integer
representation back to the probability scale is straightforward as
shown below.  However, for the \Robject{ff} objects we must first
bring the data into memory. To bring all the scores into memory, one
could use the function \Rfunction{[,]} but this could be slow and
require a lot of RAM depending on the size of the dataset.  Instead,
we suggest pulling only the needed rows and columns from memory. In
the following example, we convert the integer scores to probabilities
for the CEPH samples.  As genotype confidence scores are not
applicable to the nonpolymorphic markers, we extract only the
polymorphic markers using the \Rfunction{isSnp} function.

<<assayData>>=
rows <- which(isSnp(cnSet))
cols <- which(batch == "C")
posterior.prob <- tryCatch(i2p(snpCallProbability(cnSet.assayData_ff)),
			    error=function(e) print("This will not work for an ff object."))
posterior.prob1 <- i2p(snpCallProbability(cnSet.assayData_matrix)[rows, cols])
posterior.prob2 <- i2p(snpCallProbability(cnSet.assayData_ff)[rows, cols])
all.equal(posterior.prob1, posterior.prob2)
@ 

Next, we obtain locus-level estimates of copy number by fitting a linear
model to each SNP. A variable named 'batch' must be indicated in the
\Robject{protocolData} of the \Robject{cnSet} object. As the inverse
variance of the within-genotype normalized intensities are used as
weights in the linear model (and hence the design matrix in the
regression changes for each SNP), the time is linear with the number of
markers on the array. Copy number estimation at nonpolymorphic markers
and polymorphic markers with unobserved genotypes is more difficult. We
refer the interested reader to the technical report \citep{Scharpf2009}.
Again, we peform the copy number estimation using the matrix version and
the ff version in parallel and encourage users with large datasets to
explore the latter. As with the preprocessing and genotyping, the
following code should be submitted as part of the batch job as it is too
slow for interactive analysis.

<<cn.ff, echo=FALSE, eval=FALSE>>=
rm(cnSet); gc()
ocProbesets(75e3)
##ff objects
system.time(cnSet2 <- crlmmCopynumber2(cnSet2))
save(cnSet2, file=file.path(outdir, "cnSet2.rda"))
@ 

<<timings, eval=FALSE>>=
tryCatch(print(paste("Time for matrix version:", time1)), error=function(e) print("timing for CN estimation not available"))
tryCatch(print(paste("Time for ff version:", time2)), error=function(e) print("timing for CN estimation not available"))
rm(cnSet2); gc()
@ 


\section{Accessors}

For the remainder of this vignette, we illustrate accessors and
visualizations using the sample object provided in the
\Rpackage{crlmm} package.

<<sampleset>>=
data(sample.CNSetLM)
x <- sample.CNSetLM
@ 


\subsection{Quantile-normalized intensities}

Accessors for the quantile normalized intensities for the A allele at
polymorphic loci:

<<accessors>>=
snp.index <- which(isSnp(x))
np.index <- which(!isSnp(x))
a <- (A(x))[snp.index, ]
dim(a)
@ 

The extra set of parentheses surrounding \Robject{A(cnSet2)} above is
added to emphasize the appropriate order of operations. Subsetting the
entire \Robject{x} object in the following code should be avoided for
large datasets.

<<eval=FALSE>>=
a <- A(x[snp.index, ])
@ 

The quantile-normalized intensities for nonpolymorphic loci are obtained
by:

<<>>=
npIntensities <- (A(x))[np.index, ]
@ 

Quantile normalized intensities for the B allele at polymorphic loci:

<<B.polymorphic>>=
b.snps <- (B(x))[snp.index, ]
@ 

Note that NAs are recorded in the 'B' assay data element for
nonpolymorphic loci:

<<B.NAs>>=
all(is.na((B(x))[np.index, ]))
@ 

<<clean, echo=FALSE>>=
rm(b.snps, a, npIntensities); gc()
@ 

\paragraph{\Robject{SnpSet}: Genotype calls and confidence scores}

Genotype calls:
<<genotypes>>=
genotypes <- (snpCall(x))[snp.index, ]
@ 
Confidence scores of the genotype calls:
<<confidenceScores>>=
genotypeConf <- integerScoreToProbability(snpCallProbability(x)[snp.index[1:10], ])
@ 

\paragraph{\Robject{CopyNumberSet}: allele-specific copy number}

Allele-specific copy number at polymorphic loci:
<<ca>>=
##ca <- CA(x[snp.index, ])/100
snp.index <- which(isSnp(x))
ca <- CA(x, i=snp.index)
##or
ca <- ACN(x, "A", i=snp.index)
cb <- CB(x, i=snp.index)
ct <- ca+cb
@ 

Total copy number at nonpolymorphic loci:
<<ca>>=
cn.nonpolymorphic <- CA(obj, i=which(!isSnp(obj)))
@ 

Total copy number at both polymorphic and nonpolymorphic loci:
<<totalCopynumber>>=
##cn <- copyNumber(x)
cn <- totalCopyNumber(x, sample(1:nrow(x), 1e4), 1:5)
apply(cn, 2, median, na.rm=TRUE)
@ 

\subsection{Other accessors}

Information on physical position and chromosome can be accessed as follows:

<<positionChromosome>>=
xx <- position(x)
yy <- chromosome(x)
@ 

Parameters from the linear model used to estimate copy number are
stored in the slot \Robject{lM}. 

<<copynumberParameters>>=
names(lM(x))
dim(lM(x)[[1]])
@ 



\section{Suggested visualizations}

\paragraph{SNR.}

A histogram of the signal to noise ratio for the HapMap samples:

<<plotSnr, fig=TRUE, include=FALSE>>=
hist(x$SNR, xlab="SNR", main="", breaks=25)
@ 

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{copynumber-plotSnr}
  \caption{Signal to noise ratios for the HapMap samples.}
\end{figure}



\paragraph{One sample at a time: locus-level estimates}

Figure \ref{fig:oneSample} plots physical position (horizontal axis)
versus copy number (vertical axis) for the first sample.  There is less
information to estimate copy number at nonpolymorphic loci; improvements
to the univariate prediction regions at nonpolymorphic loci are a future
area of research.  

<<oneSample, fig=TRUE, width=8, height=4, include=FALSE>>=
par(las=1, mar=c(4, 5, 4, 2))
plot(position(x), copyNumber(x)[, 1], pch=".", 
     cex=2, xaxt="n", col="grey20", ylim=c(0,4), 
     ylab="copy number", xlab="physical position (Mb)",
     main=paste(sampleNames(x)[1], ", CHR:", unique(chromosome(x))))
points(position(x)[!isSnp(x)], copyNumber(x)[!isSnp(x), 1],
       pch=".", cex=2, col="lightblue")
axis(1, at=pretty(range(position(x))), labels=pretty(range(position(x)))/1e6)
@ 

<<idiogram, eval=FALSE, echo=FALSE>>=
require(SNPchip)
plotCytoband(22, new=FALSE, cytoband.ycoords=c(3.8, 4), label.cytoband=FALSE)
@ 

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-oneSample}
  \caption{\label{fig:oneSample} Total copy number (y-axis) for
    chromosome 1 plotted against physical position (x-axis) for one
    sample.  Estimates at nonpolymorphic loci are plotted in light
    blue.}
\end{figure}

%
%<<overlayHmmPredictions, fig=TRUE, include=FALSE>>=
%ask <- FALSE
%op <- par(mfrow=c(3, 1), las=1, mar=c(1, 4, 1, 1), oma=c(3, 1, 1, 1), ask=ask)
%##Put fit on the copy number scale
%cns <- copyNumber(cnSet2)
%cnState <- hmmPredictions - as.integer(1)
%xlim <- c(10*1e6, max(position(cnSet2)))
%cols <- brewer.pal(8, "Dark2")[1:4]
%for(j in 1:3){
%	plot(position(cnSet2), cnState[, j], pch=".", col=cols[2], xaxt="n", 
%	     ylab="copy number", xlab="Physical position (Mb)", type="s", lwd=2,
%	     ylim=c(0,6), xlim=xlim)
%	points(position(cnSet2), cns[, j], pch=".", col=cols[3])
%	lines(position(cnSet2), cnState[,j], lwd=2, col=cols[2])
%	axis(1, at=pretty(position(cnSet)), 
%	     labels=pretty(position(cnSet))/1e6)
%	abline(h=c(1,3), lty=2, col=cols[1])	
%	legend("topright", bty="n", legend=sampleNames(cnSet)[j])
%	legend("topleft", lty=1, col=cols[2], legend="copy number state",
%	       bty="n", lwd=2)
%	plotCytoband(CHR, cytoband.ycoords=c(5, 5.2), new=FALSE,
%		     label.cytoband=FALSE, xlim=xlim)
%}
%par(op)
%@ 
%
%\begin{figure}
%  \includegraphics[width=\textwidth]{copynumber-overlayHmmPredictions}
%  \caption{\label{fig:overlayHmmPredictions} Total copy number (y-axis)
%    for chromosome 22 plotted against physical position (x-axis) for
%    three samples.  Estimates at nonpolymorphic loci are plotted in
%    light blue. }
%\end{figure}

\clearpage
\paragraph{One SNP at a time}

Scatterplots of the A and B allele intensities (log-scale) can be
useful for assessing the biallelic genotype calls.  This section of
the vignette is currently under development.
% The following code chunk is
%displayed in Figure \ref{fig:prediction}.

<<predictionRegions, fig=TRUE, width=8, height=8, include=FALSE, eval=FALSE>>=
i <- snp.index[1]
#plotCNSetLM=crlmm:::plotCNSetLM
##trace(plotCNSetLM, browser)
plot(i, x, copynumber=2)
##myScatter <- function(object, add=FALSE, ...){
##	A <- log2(A(object))
##	B <- log2(B(object))
##	if(!add){
##		plot(A, B, ...)
##	} else{
##		points(A, B, ...)
##	}
##}
##index <- which(isSnp(cnSet))[1:9]
##xlim <- ylim <- c(6.5,13)
##par(mfrow=c(3,3), las=1, pty="s", ask=FALSE, mar=c(2, 2, 2, 2), oma=c(2, 2, 1, 1))
##for(i in index){
##	gt <- calls(cnSet)[i, ]
##	if(i != 89){
##		myScatter(cnSet[i, ], 
##			  pch=pch, 
##			  col=colors[snpCall(cnSet)[i, ]], 
##			  bg=colors[snpCall(cnSet)[i, ]], cex=cex,
##			  xlim=xlim, ylim=ylim)
##		mtext("A", 1, outer=TRUE, line=1)
##		mtext("B", 2, outer=TRUE, line=1)	
##		crlmm:::ellipse.CNSet(cnSet[i, ], copynumber=2, batch="C", lwd=2, col="black")
##		crlmm:::ellipse.CNSet(cnSet[i, ], copynumber=2, batch="Y", lwd=2, col="grey50")
##	} else {
##		plot(0:1, xlim=c(0,1), ylim=c(0,1), type="n", xaxt="n", yaxt="n")
##		legend("center",
##		       legend=c("CN = 2, CEPH", "CN = 2, Yoruban"),
##		       col=c("black", "grey50"), lwd=2, bty="n")
##	}
##}
@

%\begin{figure}
%  \centering
%  \includegraphics[width=0.8\textwidth]{copynumber-predictionRegions}
%  \caption{\label{fig:prediction} Scatterplots of A versus B
%    intensities.  Each panel displays a single SNP. The ellipses
%    indicate the 95\% probability region for copy number 2 for the CEPH
%    (black) and Yoruban subjects (grey).}
%\end{figure}

%\section{Details for the copy number estimation procedure}
%
%See the technical report \citep{Scharpf2009}.

\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@ 

\section*{References}

%\begin{bibliography}
  \bibliographystyle{plain}
  \bibliography{refs}
%\end{bibliography}
  

\end{document}
