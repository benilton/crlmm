%\VignetteIndexEntry{crlmm copy number Vignette}
%\VignetteDepends{crlmm, genomewidesnp6Crlmm}
%\VignetteKeywords{crlmm, SNP 6}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\usepackage[margin=1in]{geometry}

\begin{document}
\title{Copy number estimation and genotype calling with \Rpackage{crlmm}}
\date{\today}
\author{Rob Scharpf}
\maketitle

<<setup, echo=FALSE, results=hide>>=
options(continue=" ", width=70)
@

%\section{Estimating copy number}

%At present, software for copy number estimation is provided only for the
%Affymetrix 6.0 platform.

\begin{abstract}
  This vignette estimates copy number for HapMap samples on the
  Affymetrix 6.0 platform.  See \citep{Scharpf2009} for the working
  paper.

\end{abstract}

\section{Copy number estimation}

\subsection{Set up}

<<cdfname>>=
library(crlmm)
@

Several genotyping platforms are currently supported.  Supported
platforms must have a corresponding annotation package (installed
separately) that are listed below.

<<annotationPackages>>=
annotationPackages()
@

Only the annotation package that end with the 'Crlmm' postfix are
supported for copy number estimation. For instance,
'pd.genomewidesnp6' and 'genomewidesnp6Crlmm' are both annotation
packages for the Affymetrix 6.0 platform, but the
'genomewidesnp6Crlmm' annotation package must be used for copy number
estimation.  The annotation package is specified through the 'cdfName'
-- the identifier without the 'Crlmm' postfix.  In the following code,
we specify the cdf name for Affymetrix 6.0, provide the complete path
to the CEL files, and indicate where intermediate files from the copy
number estimation are to be saved.

<<>>=
cdfName <- "genomewidesnp6"
pathToCels <- "/thumper/ctsa/snpmicroarray/hapmap/raw/affy/1m"
if(getRversion() < "2.12.0"){
	rpath <- getRversion()
} else rpath <- "trunk"
outdir <- paste("/thumper/ctsa/snpmicroarray/rs/ProcessedData/crlmm/", rpath, "/copynumber_vignette", sep="")
@

All long computations are saved in the output directory
\Robject{outdir}.  Users should change these variables as appropriate.
The following code chunk should fail unless the above arguments have
been set appropriately.

<<checkSetup>>=
if(!file.exists(outdir)) stop("Please specify a valid directory for storing output")
if(!file.exists(pathToCels)) stop("Please specify the correct path to the CEL files")
@

Processed data from codechunks requiring long computations are saved
to disk by wrapping function calls in the \Robject{checkExists}
function.  After running this vignette as a batch job, subsequent
calls to \verb@Sweave@ will load the saved computations from disk. For
additional information, see the examples in the help file for the
\Rfunction{checkExists} function.

\subsection{Preprocessing and genotyping.}

In the following code chunk, we provide the complete path to the
Affymetrix CEL files and define a 'batch' variable. The
\Robject{batch} variable will be used to initialize a container for
storing the normalized intensities, the genotype calls, and the
parameter estimates for copy number.  Often the chemistry plate or the
scan date of the array is a useful surrogate for batch. For the HapMap
CEL files in our analysis, the CEPH (C) and Yoruban (Y) samples were
prepared on separate plates.  In the following code chunk, we extract
the population identifier from the CEL file names and use this as the
batch variable.

<<celfiles>>=
celFiles <- list.celfiles(pathToCels, full.names=TRUE, pattern=".CEL")
celFiles <- celFiles[substr(basename(celFiles), 13, 13) %in% c("C", "Y")]
batch <- as.factor(substr(basename(celFiles), 13, 13))
@

The preprocessing steps for copy number estimation includes quantile
normalization of the raw intensities for each probe and a step that
summarizes the intensities of multiple probes at a single locus.  For
example, the Affymetrix 6.0 platform has 3 or 4 identical probes at
each polymorphic locus and the normalized intensities are summarized
by a median.  For the nonpolymorphic markers on Affymetrix 6.0, only
one probe per locus is available and the summarization step is not
needed.

After preprocessing the arrays, the \crlmm{} package estimates the
genotype and provides a confidence score at each polymorphic locus.
Unless the dataset is small (e.g., fewer than 50 samples), we suggest
installing and loading the \R{} package \Rpackage{ff} to reduce the
RAM required for preprocessing and genotyping.  Loading the
\Rpackage{ff} package at this point will automatically enable large
data support (LDS).

The function \Rfunction{genotype} checks to see whether the
\Rpackage{ff} is loaded.  If loaded, the normalized intensities and
genotype are stored as \Robject{ff} objects on disk.  Otherwise, the
genotypes and normalized intensities are stored in matrices.  A word
of caution: the \Rfunction{genotype} function without \Rpackage{ff}
requires a potentially large amount of RAM.  We illustrate the
\Robject{genotype} function using only the first 5 CEL files (a number
to small to be used for copy number estimation). We wrap the function
\Rfunction{genotype} in the \Rfunction{checkExists} to speed up
Sweaving after the initial batch job.

<<genotype>>=
gtSet.tmp <- checkExists("gtSet.assayData_matrix",
		     .path=outdir,
		     .FUN=genotype,
		     filenames=celFiles[1:5],
		     cdfName=cdfName,
		     batch=batch[1:5])
rm(gtSet.tmp); gc()
@

A more memory efficient approach to preprocessing and genotyping is
requires the \Rpackage{ff} package.  In particular, the functions
\Rfunction{ocProbesets} and \Rfunction{ocSamples} can be used to
manage how many probesets and samples are to processed at a time and
can therefore be used to fine tune the required RAM.  The function
\Rfunction{ldPath} indicates that \Robject{ff} objects will be stored
in the directory \Robject{outdir}.

<<ff>>=
library(ff)
ldPath(outdir)
ocProbesets(100000)
ocSamples(200)
@

With LDS now enabled, we preprocess and genotype 180 samples from the
CEPH and Yoruban populations using the \R{} function
\Robject{genotypeLD}.  Users that only want the genotypes at
polymorphic loci (and not the copy number estimates) should instead
use the \R{} function \Rfunction{crlmm} or \Rfunction{crlmm2}. Again,
we wrap the call to \Rfunction{genotypeLD} in \Rfunction{checkExists}
so that subsequent calls to \verb@Sweave@ can be run interactively.


<<LDS_genotype>>=
if(!file.exists(file.path(outdir, "cnSet.rda"))){
	gtSet <- checkExists("gtSet",
			     .path=outdir,
			     .FUN=genotypeLD,
			     filenames=celFiles[1:200],
			     cdfName=cdfName,
			     batch=batch[1:200])
	class(calls(gtSet))
}
@

\subsection{Copy number estimation.}

The \Rfunction{crlmmCopynumber} computes summary statistics for each
genotype, imputes unobserved genotype centers, shrinks the
within-genotype variances, and estimates parameters for
allele-specific copy number. With \texttt{verbose=TRUE}, the above
steps for CN estimation are displayed.

<<LDS_copynumber>>=
##trace(fit.lm4, browser)
##estimateCnParameters(gtSet,type="X.NP")
##estimateCnParameters(gtSet,type="X.SNP")
##trace(fit.lm2, browser)
##estimateCnParameters(gtSet,type="NP")
##estimateCnParameters(gtSet,type="SNP")
cnSet <- checkExists("cnSet", .path=outdir, .FUN=crlmmCopynumber, object=gtSet)
##cnSet <- crlmmCopynumber(gtSet)
@

The \Rpackage{crlmmCopynumber} function no longer stores the
allele-specific estimates of copy number.  Rather, several functions
are available that will compute relatively quickly the allele-specific
estimates from the stored normalized intensities and the linear model
parameters.  For instance, for allele $k$, marker $i$, sample $j$, and
batch $p$, the estimate of allele-specific copy number are updated by
subtracting the estimated background from the observed intensity and
scaling by the slope coefficient. Specifically,

\newcommand{\A}{A}
\newcommand{\B}{B}
\begin{eqnarray}
  \label{eq:cnK}
{\hat c}_{k,ijp} &=& \mbox{max}\left\{\frac{1}{{\hat
    \phi}_{k,ip}}\left(I_{k,ijp}-{\hat \nu}_{k,ip}\right), ~0\right\}
\mbox{~for~} k \in \{\A, \B\}.
%  \label{eq:cnB} {\hat c}_{\B,ijp} &=& \mbox{max}\left\{\frac{1}{{\hat
%      \phi}_{\B,ip}}\left(I_{\B,ijp}-{\hat \nu}_{\B,ip}\right), ~0\right\}.
\end{eqnarray}.
\noindent See \cite{Scharpf2010} for details.

The functions \Rfunction{CA}, \Rfunction{CB}, and
\Rfunction{totalCopynumber} can be used to extract CN estimates from
the \Robject{CNSet} container.

<<ca>>=
##ca <- CA(x[snp.index, ])/100
snp.index <- which(isSnp(cnSet))
ca <- CA(cnSet, i=snp.index, j=1:5)
cb <- CB(cnSet, i=snp.index, j=1:5)
ct <- ca+cb
##boxplot(data.frame(ct[, 1:5]), pch=".")
@

Alternatively, total copy number can be obtained by
<<totalCopynumber.snps>>=
ct2 <- totalCopynumber(cnSet, i=snp.index, j=1:5)
all.equal(ct, ct2)
@

At nonpolymorphic loci, either the 'CA' or totalCopynumber method can
be used to obtain total copy number.

<<ca>>=
cn.nonpolymorphic <- CA(cnSet, i=which(!isSnp(cnSet)))
@

Total copy number at both polymorphic and nonpolymorphic loci:
<<totalCopynumber>>=
##cn <- copyNumber(x)
cn <- totalCopynumber(cnSet, sample(1:nrow(cnSet), 1e4), 1:5)
apply(cn, 2, median, na.rm=TRUE)
@

The above estimates can be plotted versus physical position. Accessors
for physical position and chromosome are also provided. In the
following codechunk we extract the position and chromosome for the
first 10 markers in the \Robject{cnSet} object.

<<fdAccessors>>=
position(cnSet)[1:10]
chromosome(cnSet)[1:10]
@


\section{The CNSet container}

The objects returned by the \Rfunction{genotype} and
\Rfunction{crlmmCopynumber} have assay data elements that are pointers
to \Robject{ff} objects stored in the directory \Robject{outdir}.  Had
we not loaded the \Rpackage{ff} prior to running these functions, the
\Robject{AssayData} elements would be ordinary matrices, though the
RAM required for running the algorithm would be substantial. The
functions \Rfunction{open} and \Rfunction{close} open and close the
connections to the \Robject{assayData} elements. Subsetting an
\Robject{ff} object pulls the data from disk into memory and should be
used with caution. In particular, subsetting the \Robject{gtSet} would
subset each element in the \Robject{assayData} slot, returning an
object of the same class but with \Robject{assayData} elements that
are matrices.  Such an operation can be exceedingly slow when
performed over a network and require subsantial RAM.  The preferred
approach is to extract only the assay data element that is needed. In
the example below, we extract the genotype calls for the the first 50
samples.

<<check>>=
dims(cnSet)
dims(cnSet)
print(object.size(cnSet), units="Mb")
gt <- calls(cnSet)[, 1:50]
@

The \Robject{CNSet} class also contains the slot
\Robject{batchStatistics} that contains batch-specific summaries
needed for copy number estimation. In particular, each element is a
matrix (or an ff object) with R rows and C columns, correspoinding to
R markers and C batches.  The summaries includes the within genotype
cluster medians and median absolute deviations (mads), but also
parameters estimated from the linear model.  (For unobserved
genotypes, the medians are imputed and the variance is obtained the
median variance (across markers) within a batch. ) The elements of the
slot can be listed as follows.

<<batchStatistics>>=
assayDataElementNames(batchStatistics(cnSet))
@

Note that for the Affymetrix 6.0 platform the assay data elements each
have a row dimension corresponding to the total number of polymorphic
and nonpolymorphic markers interrogated by the Affymetrix 6.0
platform.  A consequence of keeping the rows of the assay data
elements the same for all of the statistical summaries is that the
matrix used to store genotype calls is larger than necessary.  Also,
note the additional overhead of some operations when using
\Robject{ff} objects.  For instance, the posterior probabilities for
the CRLMM genotype calls are represented as integers. The accessor
\Robject{snpCallProbability} can be used to access these confidence
scores.  When stored as matrices, converting the integer
representation back to the probability scale is straightforward as
shown below.  However, for the \Robject{ff} objects we must first
convert the ff object to a matrix. One could use the function
\Rfunction{[,]} but this could be slow and require a lot of RAM
depending on the size of the dataset. We suggest pulling only the
needed rows and columns from memory. In the following example, we
convert the integer scores to probabilities for the CEPH samples.  As
genotype confidence scores are not applicable to the nonpolymorphic
markers, we extract only the polymorphic markers using the
\Rfunction{isSnp} function.

<<assayData>>=
rows <- which(isSnp(cnSet))
cols <- which(batch == "C")
posterior.prob <- tryCatch(i2p(snpCallProbability(cnSet)),
			   error=function(e) print("This will not work for an ff object."))
posterior.prob2 <- p2i(snpCallProbability(cnSet)[rows, cols])
@

Accessors for the quantile normalized intensities for the A allele at
polymorphic loci:

<<accessors>>=
snp.index <- which(isSnp(cnSet))
np.index <- which(!isSnp(cnSet))
a <- (A(cnSet))[snp.index, ]
dim(a)
@

The extra set of parentheses surrounding \Robject{A(cnSet2)} above is
added to emphasize the appropriate order of operations. Subsetting the
entire \Robject{cnSet} object in the following, unevaluated codechunk
should be avoided for large datasets.

<<eval=FALSE>>=
a <- A(cnSet[snp.index, ])
@

The quantile-normalized intensities for nonpolymorphic loci are
obtained by:

<<>>=
npIntensities <- (A(cnSet))[np.index, ]
@

Quantile normalized intensities for the B allele at polymorphic loci:

<<B.polymorphic>>=
b.snps <- (B(cnSet))[snp.index, ]
@

Note that NAs are recorded in the 'B' assay data element for
nonpolymorphic loci:

<<B.NAs>>=
all(is.na((B(cnSet))[np.index, ]))
@

<<clean, echo=FALSE>>=
rm(b.snps, a, npIntensities); gc()
@

\paragraph{\Robject{SnpSet}: Genotype calls and confidence scores}

Genotype calls:
<<genotypes>>=
genotypes <- (snpCall(cnSet))[snp.index, ]
@
Confidence scores of the genotype calls:
<<confidenceScores>>=
genotypeConf <- integerScoreToProbability(snpCallProbability(cnSet)[snp.index[1:10], ])
@

\paragraph{\Robject{CopyNumberSet}: allele-specific copy number}



\subsection{Other accessors}

Information on physical position and chromosome can be accessed as follows:

<<positionChromosome>>=
xx <- position(cnSet)
yy <- chromosome(x)
@

Parameters from the linear model used to estimate copy number are
stored in the slot \Robject{batchStatistics}.

<<copynumberParameters>>=
assayDataElementNames(batchStatistics(cnSet))
@

TODO: Describe accessors for batch-level summaries.


\section{Suggested visualizations}

\paragraph{SNR.}

A histogram of the signal to noise ratio for the HapMap samples:

<<plotSnr, fig=TRUE, include=FALSE>>=
hist(cnSet$SNR, xlab="SNR", main="", breaks=25)
@

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{copynumber-plotSnr}
  \caption{Signal to noise ratios for the HapMap samples.}
\end{figure}



\paragraph{One sample at a time: locus-level estimates}

Figure \ref{fig:oneSample} plots physical position (horizontal axis)
versus copy number (vertical axis) for the first sample.  There is less
information to estimate copy number at nonpolymorphic loci; improvements
to the univariate prediction regions at nonpolymorphic loci are a future
area of research.

<<oneSample, fig=TRUE, width=8, height=4, include=FALSE>>=
par(las=1, mar=c(4, 5, 4, 2))
plot(position(cnSet), copyNumber(cnSet)[, 1], pch=".",
     cex=2, xaxt="n", col="grey20", ylim=c(0,4),
     ylab="copy number", xlab="physical position (Mb)",
     main=paste(sampleNames(cnSet)[1], ", CHR:", unique(chromosome(cnSet))))
points(position(cnSet)[!isSnp(cnSet)], copyNumber(cnSet)[!isSnp(cnSet), 1],
       pch=".", cex=2, col="lightblue")
axis(1, at=pretty(range(position(cnSet))), labels=pretty(range(position(cnSet)))/1e6)
@

<<idiogram, eval=FALSE, echo=FALSE>>=
require(SNPchip)
plotCytoband(22, new=FALSE, cytoband.ycoords=c(3.8, 4), label.cytoband=FALSE)
@

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-oneSample}
  \caption{\label{fig:oneSample} Total copy number (y-axis) for
    chromosome 1 plotted against physical position (x-axis) for one
    sample.  Estimates at nonpolymorphic loci are plotted in light
    blue.}
\end{figure}

%
%<<overlayHmmPredictions, fig=TRUE, include=FALSE>>=
%ask <- FALSE
%op <- par(mfrow=c(3, 1), las=1, mar=c(1, 4, 1, 1), oma=c(3, 1, 1, 1), ask=ask)
%##Put fit on the copy number scale
%cns <- copyNumber(cnSet2)
%cnState <- hmmPredictions - as.integer(1)
%xlim <- c(10*1e6, max(position(cnSet2)))
%cols <- brewer.pal(8, "Dark2")[1:4]
%for(j in 1:3){
%	plot(position(cnSet2), cnState[, j], pch=".", col=cols[2], xaxt="n",
%	     ylab="copy number", xlab="Physical position (Mb)", type="s", lwd=2,
%	     ylim=c(0,6), xlim=xlim)
%	points(position(cnSet2), cns[, j], pch=".", col=cols[3])
%	lines(position(cnSet2), cnState[,j], lwd=2, col=cols[2])
%	axis(1, at=pretty(position(cnSet)),
%	     labels=pretty(position(cnSet))/1e6)
%	abline(h=c(1,3), lty=2, col=cols[1])
%	legend("topright", bty="n", legend=sampleNames(cnSet)[j])
%	legend("topleft", lty=1, col=cols[2], legend="copy number state",
%	       bty="n", lwd=2)
%	plotCytoband(CHR, cytoband.ycoords=c(5, 5.2), new=FALSE,
%		     label.cytoband=FALSE, xlim=xlim)
%}
%par(op)
%@
%
%\begin{figure}
%  \includegraphics[width=\textwidth]{copynumber-overlayHmmPredictions}
%  \caption{\label{fig:overlayHmmPredictions} Total copy number (y-axis)
%    for chromosome 22 plotted against physical position (x-axis) for
%    three samples.  Estimates at nonpolymorphic loci are plotted in
%    light blue. }
%\end{figure}

\clearpage
\paragraph{One SNP at a time}

Scatterplots of the A and B allele intensities (log-scale) can be
useful for assessing the biallelic genotype calls.  This section of
the vignette is currently under development.

\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@

\section*{References}

%\begin{bibliography}
  \bibliographystyle{plain}
  \bibliography{refs}
%\end{bibliography}


\end{document}
